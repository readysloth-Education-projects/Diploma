\chapter{Формализация процесса создания эмуляторов аппаратного обеспечения}\label{ch:ch2}

Помимо сказанного в главе \ref{sec:ch1/sec4} для создании эмуляторов аппаратного обеспечения
требуется формализовать данную задачу.

\section{Подход}\label{sec:ch2/sec1}

Подход к решению обозначенных проблем будет основываться на эмуляторе QEMU и его
возможности встраивать пользовательские устройства.
Для этого необходимо:

\begin{enumerate}[label={\arabic*)}]
    \item \label{q-inh} проанализировать цепочки наследования сущностей QOM;
    \item \label{q-inh-scheme} составить схему наследования сущностей;
    \item \label{q-interface} определить интерфейс взаимодействия эмулятора с выделенными сущностями;
    \item \label{q-impl} реализовать устройство;
\end{enumerate}

Корректность выполнения пунктов \ref{q-inh}-\ref{q-interface} должна полностью брать на себя разрабатываемая система,
тогда как вместо предоставления автосгенерированного файла с исходным кодом \ref{sec:ch1/sec2} для
последующей модификации, результатом выполнения пункта \ref{q-impl} должен быть готовый к встраиванию
файл с исходным кодом, не требующий ручной модификации.
Для этого требуется проблемно-ориентированный язык, компиляция которого, помимо генерации шаблонного кода
создаст интерфейс передачи объектов между C-устройством внутри QEMU и интерпретатором Python, в
котором будет исполняться реализованная логика работы устройства.

С учетом всего вышесказанного, На рис. \ref{fig:device-compilation} показана функциональная схема преобразования
описания виртуального устройства в часть эмулятора QEMU.

\begin{figure}[!htbp]
    \centering
    \input{images/func-scheme.tikz}
    \caption{Функциональная схема компиляции виртуального устройства.}\label{fig:device-compilation}
\end{figure}


\subsection{Язык описания виртуального устройства}\label{sec:ch2/sec1/sub1}

Использование специализированного языка для описания устройства, в отличие от языка общего назначения (см. \ref{sec:ch1/sec2}),
имеет как определенные преимущества, так и недостатки.
К преимуществам можно отнести:
\begin{itemize}
    \item ограничение пользователя языка только необходимыми конструкциями -- минимизация ошибок программирования;
    \item точные, по сравнению с языком общего назначения, сообщения об ошибках;
    \item самодокументируемость решения проблемы;
    \item более эффективная, по времени, разработка.
\end{itemize}

К недостаткам -- необходимость предварительного изучения проблемно-ориентированного языка.
Как можно убедиться, преимуществ, несмотря на определенную трудоемкость разработки такого языка,
больше.
Необходимость изучения дополнительного языка для описания виртуального устройства может показаться
избыточной, но использование языка общего назначения (см. \ref{sec:ch1/sec2}),
пусть и популярного, не гарантирует, что пользователь его знает и эффективно в нем работает.
Помимо этого, изучение небольшого языка для решения конкретной проблемы будет эффективнее
изучения библиотеки и некоторого подмножества полноценного языка программирования,
из которого ее можно будет использовать.

Ограничение в языковых конструкциях и анализ семантики исходного кода
позволяет точно инструктировать пользователя об ошибках в реализации виртуального устройства,
что ведет к отсутствию ошибок уровня интерфейса устройства,
сводя появление возможных неисправностей только до реализации логики устройства.

Язык-фреймворк Racket \cite{racket-lang} разработан как раз для языково-ориентированного
программирования. Написание на нем логики компилятора или интерпретатора целевого языка
полуавтоматически создает интегрированную среду разработки с помощью IDE DrRacket, которую
также поддерживает сообщество.
После объявления некоторых функций \cite{racket-drracket-integration}, разработчик программ
на целевом языке сможет пользоваться подсветкой синтаксиса, отладчиком, автоматическим добавлением
отступов и указателями использования переменных (рис. \ref{fig:racket-variable-arrow}), что дополнительно облегчает разработку.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/racket-variable-arrow.png}
    \end{adjustbox}
    \caption{Результат интеграции языка datalog в IDE DrRacket.}\label{fig:racket-variable-arrow}
\end{figure}


\subsubsection{Структура программы}\label{sec:ch2/sec1/sub1/sub1}

Структура программы-описания аппаратного обеспечения имеет следующий вид, рисунок \ref{fig:device-program-structure}.

\begin{figure}[!htbp]
    \centering
    \input{images/program-structure.tikz}
    \caption{Структура программы-описания аппаратного обеспечения.}\label{fig:device-program-structure}
\end{figure}

Несмотря на то, что компилятор язык программы-описания располагает
блоки кода в результирующем тексте модуле QEMU в соответствии
с правилами языка C и порядок объявления блоков в исходном файле ему не важен,
данная структура является наиболее понятной и органичной для стороннего разработчика.
Поэтому компилятор принуждает программиста придерживаться её, подобно тому, как
язык Python обязывает использовать отступы для создания блоков кода.


\subsubsection{Граммматика языка}\label{sec:ch2/sec1/sub1/sub2}
Разрабатываемый язык является языком с контекстно-свободной грамматикой.
Далее он будет именоваться как {\mylanguage} (произносится \mylanguageprononciation)

Грамматика {\mylanguage} ограничена до описания зависимостей устройства и QEMU,
связывания функций C и Python, встраивания Python-кода с логикой работы устройства
в файл.


% TODO: Учтено ли, что пользователь захочет кастомизировать функции инициализации класса и инстанса?
% TODO: MemoryRegionOps?
\begin{figure}[!htbp]
    \begin{grammar}
        <letter> ::= `a' ... `z' | `A' ... `Z';

        <digit> ::= `0' ... `9' ;

        <symbol> ::= \symbol{92}x20 ... \symbol{92}x7E ; (* любой печатный символ, согласно кодам ASCII *)

        <const value> ::= <digit> | `"' \{ <symbol> \} `"';

        <identifier> ::= <letter> [\{ <letter> | <digit> | `\_' \}] ;

        <block start> ::= `{';

        <block end> ::= `}';

        <field> ::= <identifier> `=' <identifier> | <block> ;

        <block> ::= <block start> <field> [\{ `,' <field> \}] <block end>;

        <device definition> ::= '\#' <identifier>;

        <device class inheritance> ::= `(' <identifier> `:' <identifier> [\{ `,' <identifier> \}] `)';

        <device class block> ::= <device class inheritance> <block>;

        <bind block> ::= `@bind' <block>;

        <python block> ::= `@py' <block>;

        <program> ::= <device definition> <device class block> <bind block> <python block>;
    \end{grammar}
    \caption{Расширенная форма Бэкуса-Наура \mylanguage}\label{fig:qpydev-grammar}
\end{figure}


\subsubsection{Семантика языка}\label{sec:ch2/sec1/sub1/sub3}

Для описания семантики языка {\mylanguage} была выбрана денотационная семантика.
Краеугольным камнем денотационной семантики является определение для каждой сущности
языка некоего математического объекта и некоей функции, называемой интерпретатором,
которая отображает экземпляры этой сущности в экземпляры этого математического объекта -- элемент множества денотаций.
Поскольку математические объекты строго определены, то они представляют собой точный
смысл соответствующих сущностей.

Функции обозначают посредством двойных квадратных скобок $[[$ $]]$,
а элемент алгебры или операция алгебры, сопоставленные функцией $[[$ $]]$
правильному выражению или конструктору выражений, называют денотантом этого выражения или,
соответственно, денотацией конструкции. \cite{denotational-semantics}

Для языка {\mylanguage} значимыми множествами семантических объектов
являются только множества $Q$ -- объектов QEMU (переменные, функции, структуры) и
$C$ -- множество константных выражений.


\begin{figure}[!htbp]
    \centering
    \begingroup
    \addtolength{\jot}{1em}
    \begin{gather*}
        [[assignment]](x,y) = \lambda x.y \\
        [[terminate]](m) \text{ Завершение работы компилятора} \\
        [[if]](c,e_1,e_2) =
        \begin{cases}
            e_1, & \text{Если } c = true \\
            e_2, & \text{Если } c \not= true
        \end{cases} \\
        [[throw\ error]](c, e) = if(c, e_g, terminate) \\
        [[lookup]](o) = [[throw\ error]](o \in Q, o) \\
        [[<device\ definition>]](i) = lookup(i) \\
        [[<device\ class\ inheritance>]](i_1,...,i_n) = lookup(i_1) + ... + lookup(i_n) \\
        [[<field>]](v_1, v_2) = assignment(v_1, v_2), \text{ Если } v_1 \in Q \text{ и } v_3 \in C \cup Q \\
        [[<block>]](f_1,...,f_n) = field(f_1) + ... + field(f_n) \\
        [[<python block>]](b) = assignment(B,B)\\
    \end{gather*}
    \endgroup
    \caption{Денотационная семантика {\mylanguage}}\label{fig:denotational-semantics}
\end{figure}


\subsection{Поиск используемых сущностей QEMU}\label{sec:ch2/sec1/sub2}

Пробрасывание -- процесс преобразовывания и передачи данных между двумя интерфейсами.

Поиск используемых сущностей состоит в установлении типов QEMU для последующего
корректного пробрасывания их в логику устройства.
Также это необходимо для проверки корректности наследования и встраивания устройства.
Необходимыми для пробрасывания типами являются структуры и функции, оперирующие ими.

Рекурсивное преобразование структур QEMU в типы python важно для удобного и читаемого
использования C-объектов внутри python-логики.
Пробрасывание в python функций QEMU необходимо для использования уже имеющегося API эмулятора.
% TODO: может удалить, если это сложно
Потенциально, может быть удобным использование макросов препроцессора C внутри
логики Python.

Базовым классом для всех классов QEMU является класс \texttt{Object}.
Наследование происходит через определение первым членом C-структуры
указателя на структуру-родитель данной. Так как язык C гарантирует, что
первый член структуры всегда начинается с нулевого отступа от начала
структуры, любой класс можно привести к типу Object.
В свою очередь Object содержит структуру, описывающую класс приведенного
объекта -- \texttt{ObjectClass}, что позволяет определить реальный тип указателя
во время исполнения.

Структуры \texttt{TypeImpl} и \texttt{TypeInfo} (см рис. \ref{fig:qom-structure}) практически не отличаются,
но служат для разных целей:
\texttt{TypeImpl} является <<внутренним>> содержанием класса, служебной структурой,
которая скрывает методы класса от пользователя интерфейса, тогда как \texttt{TypeInfo}
наоборот, предоставляет уже очищенный от служебных полей интерфейс для инициализации \texttt{TypeImpl}.

После объявления \texttt{TypeInfo}, структура регистрируется в объектной системе QEMU.
Это происходит через использование макроса \texttt{type\_init}, который создает, можно считать,
анонимную функцию, в свою очередь вызывающую функцию \texttt{register\_module\_init}.
Созданная анонимная функция помечается атрибутом \texttt{constructor} \cite{gcc-attributes}, что заставляет
компилятор добавить вызов такой функции до вызова функции main.
Соответственно, инициализация модулей происходит до того, как начнет исполняться логика QEMU.

% TODO: А точно ли?

Все перефирийные устройства, добавляемые в QEMU, <<общаются>> с другими устройствами через чтение и запись
по определенным для устройства адресам памяти.
За это отвечает структура \texttt{MemoryRegionOps} \ref{fig:mem-reg-ops},
которая инициализируется функциями чтения и записи,
которые вызываются, соответственно, при чтении или записи памяти, на которое <отображено>> устройство.
Данные функции принимают на вход указатель на устройство, в чью память происходит чтение или запись,
адрес, по которому происходит чтение или запись, и, в случае чтения, количество читаемых байт,
а в случае записи -- записываемое значение и количество записываемых байт.
Некоторые устройства используют расширенные версии чтения и записи, где последним аргументом передается
структура с атрибутами транзакции.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/mem_reg_ops_cropped.png}
    \end{adjustbox}
    \caption{Связь \texttt{MemoryRegionOps} с другими сущностями QEMU.}\label{fig:mem-reg-ops}
\end{figure}


\subsubsection{Механизм нахождения информации о типах устройств}\label{sec:ch2/sec1/sub2/sub1}

Все устройства QEMU:
\begin{enumerate}[label={\arabic*)}]
    \item имеют родителя и распределены по подпапкам папки \texttt{hw};
    \item объявляют структуру \texttt{TypeInfo}, в которой указывается родитель устройства
          и размер создаваемого объекта -- поле \texttt{.instance\_size}
          (используется для создания объектов устройств на системной шине);
    \item используют оператор \texttt{sizeof},
          передавая ему имя структуры устройства, которое будет исполняться в QEMU.
\end{enumerate}

Данная информация позволяет найти используемые сущности QEMU следующим образом:
\begin{enumerate}[label={\arabic*)}]
    \item пройтись по всем файлам, находящимся в папке \texttt{hw};
    \begin{enumerate}[label={\arabic*)}]
        \item найти структуру \texttt{TypeInfo};
        \item проанализировать поле \texttt{.instance\_size} и сохранить
              используемую структуру как возможную для наследования;
        \item сохранить поле \texttt{.name} в качестве имени структуры для наследования;
    \end{enumerate}
\end{enumerate}

Помимо явного описания структуры \texttt{TypeInfo} некоторые устройства, написанные
в современном стиле, используют макросы:
\begin{enumerate}[label={\arabic*)}]
    \item \label{main-def-macro} \texttt{OBJECT\_DEFINE\_TYPE\_EXTENDED};
    \item \texttt{OBJECT\_DEFINE\_TYPE};
    \item \texttt{OBJECT\_DEFINE\_TYPE\_WITH\_INTERFACES};
    \item \texttt{OBJECT\_DEFINE\_ABSTRACT\_TYPE}.
\end{enumerate}

Все перечисленные макросы создают структуру \texttt{TypeInfo} и все, кроме \ref{main-def-macro},
вызывают внутри себя макрос \ref{main-def-macro}, специализируя определенные поля структуры \texttt{TypeInfo}.
Например \texttt{OBJECT\_DEFINE\_ABSTRACT\_TYPE} создает абстрактный тип, передавая внутри себя
значение \texttt{true} макросу \texttt{OBJECT\_DEFINE\_TYPE\_EXTENDED}, чем облегчает собственный интерфейс
и делает свое использование более выразительным.

Список аргументов макросов объявления типов также требуется разбирать, чтобы получить из аргументов информацию
о структуре \texttt{TypeInfo}.

Механизм получения информации о функциях намного проще: в языке C функции могут инкапсулироваться
только на уровне одного модуля трансляции -- C-файла, прошедшего этап препроцессирования.
Инкапсулированные функции помечаются ключевым словом \texttt{static}, что делает их
<<невидимыми>> в других модулях трансляции.
Все функции, не помеченные ключевым словом \texttt{static} будем считать интерфейсными.

Данная информация будет использована впоследствии для корректной кодогенерации устройства
и преобразования C-структур и C-функций в читаемый вид для python-интерфейса.

\subsubsection{Механизм использования информации о типах устройств}\label{sec:ch2/sec1/sub2/sub2}

Так как код QEMU насыщен использованием макросов, потребуется инструмент для их разворачивания -- препроцессор.
Чтобы не создавать собственную имплементацию препроцессора, этим будет заниматься препоцессор системного компилятора.

Практически во всех системах сборки программ в POSIX окружении используется компилятор gcc или clang.
Оба компилятора являются совместимыми между собой. Для задействования препроцессора компилятора используется
опция \texttt{-E}. Так как препроцессор C, помимо раскрытия макросв занимается еще нахождением и подстановкой
заголовочных файлов, то потребуется указать папки с их местонахождением.
QEMU полагается на:
\begin{enumerate}[label={\arabic*)}]
    \item \label{build-header} заголовочные файлы, создаваемые в процессе сборки эмулятора;
    \item библиотеку GLib;
    \item заголовочные файлы, находящиеся в папке \texttt{include}.
\end{enumerate}

Так как файлы в пункте \ref{build-header} появляются в процессе сборки, то конкретную версию QEMU нужно будет собрать.
Сборка также полезна, так как в процессе конфигурации эмулятора выставляются определенные переменные
препроцессора (дефайны -- от директивы \texttt{\#define}), которые влияют на условные выражения
препроцессора, а те, в свою очередь, на генерацию исходного кода.
Использование в данном случае статического анализатора кода было бы затруднительным, так как
информация о конкретной конфигурации не может быть получена без непосредственной сборки.

Укзание папки для препроцессора производится с помощью опции \texttt{-I}.
\begin{lstlisting}[caption={Пример строки запуска препроцессора для определенного файла устройства},
                   captionpos=b]
gcc -E hw/misc/edu.c
    -I ./include/
    -I ./build/
    -I/usr/include/glib-2.0
    -I/usr/lib64/glib-2.0/include
\end{lstlisting}


\subsection{Генерация python-интерфейса для логики устройства}\label{sec:ch2/sec1/sub3}

Определение интерфейса используемых сущностей QEMU происходит над препроцессированными данными \ref{sec:ch2/sec1/sub2/sub2}.



% TODO: Учтено ли, что пользователь захочет кастомизировать функции инициализации класса и инстанса?
Python-интерфейс 

\subsection{Генерация C-интерфейса устройства в QEMU}\label{sec:ch2/sec1/sub4}
\subsection{Проброс ошибок QEMU из и в Python}\label{sec:ch2/sec1/sub5}
\subsection{Встраивание устройства в сборку QEMU}\label{sec:ch2/sec1/sub6}
\subsection{Сборка QEMU}\label{sec:ch2/sec1/sub7}
