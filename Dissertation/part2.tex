\chapter{Формализованное представление алгоритма генерации виртуального аппаратного обеспечения по спецификации}\label{ch:ch2}

В \cref{sec:ch1/sec4}, были описаны некоторые преимущества
создания DSL-языка для описания виртуального аппаратного обеспечения.
Теперь же требуется формализовать задачу создания виртуального аппаратного обеспечения и создаваемый DSL-язык.

\section{Методика и алгоритм создания виртуального аппаратного обеспечения}\label{sec:ch2/sec1}

Методика по решению обозначенных проблем будет основываться на эмуляторе QEMU и его
возможности встраивать пользовательское виртуальное аппаратное обеспечение.
Для этого необходимо:

\begin{enumerate}[label={\arabic*)}]
    \item \label{q-inh} проанализировать цепочки наследования сущностей QOM;
    \item \label{q-inh-scheme} составить схему наследования сущностей;
    \item \label{q-interface} определить интерфейс взаимодействия эмулятора с выделенными сущностями;
    \item \label{q-impl} реализовать устройство;
\end{enumerate}

Корректность выполнения пунктов\cref{q-inh}-\cref{q-interface} должна полностью брать на себя разрабатываемая система,
тогда как вместо предоставления автосгенерированного файла с исходным кодом\cref{sec:ch1/sec2} для
последующей модификации, результатом выполнения пункта\cref{q-impl} должен быть готовый к встраиванию
файл с исходным кодом, не требующий ручной модификации (см. \cref{fig:device-methodics}).
Для этого требуется проблемно-ориентированный язык, компиляция которого, помимо генерации шаблонного кода
создаст интерфейс передачи объектов между C-устройством внутри QEMU и интерпретатором Python, в
котором будет исполняться реализованная логика работы устройства.

С учетом всего вышесказанного, на \cref{fig:device-compilation} показан алгоритм преобразования
описания виртуального устройства в часть эмулятора QEMU.

\begin{figure}[!htbp]
    \centering
    \input{images/func-scheme.tikz}
    \caption{Алгоритм компиляции виртуального устройства.}\label{fig:device-compilation}
\end{figure}


\begin{figure}[!htbp]
    \centering
    \input{images/methodics.tikz}
    \caption{Методика создания виртуального устройства.}\label{fig:device-methodics}
\end{figure}


\subsection*{Язык описания виртуального устройства}\label{sec:ch2/sec1/sub1}

Использование специализированного языка для описания устройства, в отличие от языка общего назначения (см. \cref{sec:ch1/sec2}),
имеет как определенные преимущества, так и недостатки.
К преимуществам можно отнести:
\begin{itemize}
    \item ограничение пользователя языка только необходимыми конструкциями -- минимизация ошибок программирования;
    \item точные, по сравнению с языком общего назначения, сообщения об ошибках;
    \item самодокументируемость решения проблемы;
    \item более эффективная, по времени, разработка.
\end{itemize}

К недостаткам -- необходимость предварительного изучения проблемно-ориентированного языка.
Как можно убедиться, преимуществ, несмотря на определенную трудоемкость разработки такого языка,
больше.
Необходимость изучения дополнительного языка для описания виртуального устройства может показаться
избыточной, но использование языка общего назначения (см.\cref{sec:ch1/sec2}),
пусть и популярного, не гарантирует, что пользователь его знает и эффективно в нем работает.
Помимо этого, изучение небольшого языка для решения конкретной проблемы будет эффективнее
изучения библиотеки и некоторого подмножества полноценного языка программирования,
из которого ее можно будет использовать.

Ограничение в языковых конструкциях и анализ семантики исходного кода
позволяет точно инструктировать пользователя об ошибках в реализации виртуального устройства,
что ведет к отсутствию ошибок уровня интерфейса устройства,
сводя появление возможных неисправностей только до реализации логики устройства.

Язык-фреймворк Racket \cite{racket-lang} разработан как раз для языково-ориентированного
программирования. Написание на нем логики компилятора или интерпретатора целевого языка
полуавтоматически создает интегрированную среду разработки с помощью IDE DrRacket \cite{drracket}, которую
также поддерживает сообщество.
После объявления некоторых функций \cite{racket-drracket-integration}, разработчик программ
на целевом языке сможет пользоваться подсветкой синтаксиса, отладчиком, автоматическим добавлением
отступов и указателями использования переменных (\cref{fig:racket-variable-arrow}), что дополнительно облегчает разработку.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={0.8\textwidth}{\textheight}}
        \includegraphics[]{images/racket-variable-arrow.png}
    \end{adjustbox}
    \caption{Результат интеграции языка datalog в IDE DrRacket.}\label{fig:racket-variable-arrow}
\end{figure}


\subsubsection{Структура программы}\label{sec:ch2/sec1/sub1/sub1}

Структура программы-описания аппаратного обеспечения имеет следующий вид, \cref{fig:device-program-structure}.

\begin{figure}[!htbp]
    \centering
    \input{images/program-structure.tikz}
    \caption{Структура программы-описания аппаратного обеспечения.}\label{fig:device-program-structure}
\end{figure}

Несмотря на то, что компилятор DSL-языка располагает
блоки кода в результирующем тексте модуле QEMU в соответствии
с правилами языка C и порядок объявления блоков в исходном файле ему не важен,
данная структура является наиболее понятной и органичной для стороннего разработчика.
Поэтому компилятор принуждает программиста придерживаться её, подобно тому, как
язык Python обязывает использовать отступы для создания блоков кода.

\section{Формализация задачи создания виртуального АО}\label{sec:ch2/sec2/sub1}
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{0pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt}

Формализацией задачи создания виртуального аппаратного
обеспечения является в математическом выражении времени разработки
аппаратного обеспечения и формализованном представлении разрабатываемого языка программирования.

Время разработки виртуального аппаратного обеспечения рассчитывается по формуле:
\begin{equation}
    T = L + D + C + R
\end{equation}
где
\begin{itemize}
    \item $T$ -- общее время разработки виртуального аппаратного обеспечения;
    \item $L$ -- время анализа QOM для реализации виртуального аппаратного обеспечения;
    \item $D$ -- описание устройства в терминах QOM;
    \item $C$ -- программирование логики устройства;
    \item $R$ -- тестирование и отладка.
\end{itemize}

Порог вхождения в QOM для программиста высок, из-за чего
$L + D > C + R$.
В данном исследовании стоит задача уменьшения компонент $L$ и $D$,
для сокращения общего времени разработки виртуального аппаратного
обеспечения.

Пусть задан ориентированный взвешенный граф $G = (V,E)$,
где
\begin{itemize}
    \item $v \in V$ -- коммит в системе контроля версий;
    \item $e=(v_i,v_{i+1}) \in E$ -- изменение виртуального
        аппаратного обеспечения от коммита $v_i$ до коммита $v_{i+1}$;
    \item вес $f(e)$ ребра $e=(v_i,v_{i+1}) \in E$ -- время на формирование коммита $v_{i+1}$
\end{itemize}
\begin{equation}
    f : E \rightarrow \mathbb{R}
\end{equation}

Общее время, затраченное на формирование цепочки коммитов:

\begin{equation}
    T = \sum_{i=1}^{|E|} f(e_i)
\end{equation}

Так как написание виртуального аппаратного обеспечения
начинается с анализа QOM и описания его в терминах QOM,
то <<разрыв>> между коммитами в начале истории будет больше, чем
на этапах программирования логики, тестировании и отладки.

Также, несколько уменьшается компонента $C$ в ущерб производительности,
благодаря использованию для описания логики устройства
популярного скриптового языка Python.

\subsection{Грамматика языка}\label{sec:ch2/sec2/sub2}
Разрабатываемый язык является языком с контекстно-свободной грамматикой.
Далее он будет именоваться как {\mylanguage} (произносится \mylanguageprononciation)

Грамматика {\mylanguage} ограничена до описания зависимостей устройства и QEMU,
связывания функций C и Python, встраивания Python-кода с логикой работы устройства
в файл.


% TODO: Учтено ли, что пользователь захочет кастомизировать функции инициализации класса и инстанса?
% TODO: MemoryRegionOps?
\setlength{\grammarparsep}{0.1cm}
\setlength{\grammarindent}{13em}
\begin{figure}[!htbp]
    \begin{grammar}
        <letter> ::= `a' ... `z' | `A' ... `Z';

        <digit> ::= `0' ... `9' ;

        <symbol> ::= \symbol{92}x20 ... \symbol{92}x7E ; (* любой печатный символ, согласно кодам ASCII *)

        <const value> ::= <digit> | `"' \{ <symbol> \} `"';

        <identifier> ::= <letter> [\{ <letter> | <digit> | `\_' \}] ;

        <block start> ::= `{';

        <block end> ::= `}';

        <field> ::= <identifier> `=' <identifier> | <block> ;

        <block> ::= <block start> <field> [\{ `,' <field> \}] <block end>;

        <device definition> ::= '\#' <identifier>;

        <device class inheritance> ::= `(' <identifier> `:' <identifier> [\{ `,' <identifier> \}] `)';

        <device class block> ::= <device class inheritance> <block>;

        <bind block> ::= `@bind' <block>;

        <python block> ::= `@py' <block>;

        <program> ::= <device definition> <device class block> <bind block> <python block>;
    \end{grammar}
    \caption{Расширенная форма Бэкуса-Наура \mylanguage}\label{fig:qpydev-grammar}
\end{figure}


\subsection{Семантика языка}\label{sec:ch2/sec2/sub3}

Для описания семантики разработанного автором языка была выбрана денотационная семантика \cite{denotational-semantics},
\cref{table:denotational-semantics}.
Краеугольным камнем денотационной семантики является определение для каждой сущности
языка некоего математического объекта и некоей функции, называемой интерпретатором,
которая отображает экземпляры этой сущности в экземпляры этого математического объекта -- элемент множества денотаций.
Поскольку математические объекты строго определены, то они представляют собой точный
смысл соответствующих сущностей.

Функции обозначают посредством двойных квадратных скобок $[[$ $]]$,
а элемент алгебры или операция алгебры, сопоставленные функцией $[[$ $]]$
правильному выражению или конструктору выражений, называют денотантом этого выражения или,
соответственно, денотацией конструкции. \cite{denotational-semantics}

Для языка {\mylanguage} значимыми множествами семантических объектов
являются только множества $Q$ -- объектов QEMU (переменные, функции, структуры) и
$C$ -- множество константных выражений.


\renewcommand*{\arraystretch}{1.5}
\begin{longtable}{| c | p{6cm} |}
    \caption{Денотационная семантика {\mylanguage}}\label{table:denotational-semantics} \\
    \hline
    \text{Математическое описание} & \multicolumn{1}{|c|}{Значение} \\
    \hline
    $[[assignment]](x,y) = \lambda x.y$
    & Операция присваивания значения $y$ переменной $x$ \\
    \hline
    \makecell{$[[terminate]](m) =$\\ \text{Завершение работы компилятора}}
    & Терминирование компилятора с сообщением $m$ \\
    \hline
    $[[if]](c,e_1,e_2) =
    \begin{cases}
        e_1, & \text{Если } c = true \\
        e_2, & \text{Если } c \not= true
    \end{cases}$
    & Условное исполнение. Если условие $c$ истинно, то
    выполняется $e_1$, иначе $e_2$ \\
    \hline
    $[[throw\ error]](c, e) = if(c, e_g, terminate)$
    & Создание и бросание исключения при ложном условии $c$ \\
    \hline
    $[[lookup]](o) = [[throw\ error]](o \in Q, o)$
    & Поиск объекта $o$ в множестве объектов QEMU $Q$.
    В случае, если объект не найден генерируется исключение \\
    \hline
    $[[<device\ definition>]](i) = lookup(i)$
    & Поиск указанного класса устройства в объектах QEMU \\
    \hline
    \makecell{$[[<device\ class\ inheritance>]](i_1,...,i_n) = $\\
              $lookup(i_1) \land ... \land lookup(i_n)$}
    & Поиск указанного класса для наследования и интерфейсов
    в объектах QEMU. Для успешного завершения должны быть
    найдены все объекты \\
    \hline
    \makecell{$[[<field>]](v_1, v_2) = $\\
              $[[throw\ error]](v_1 \in Q \land v_2 \in C \cup Q,$\\
              $assignment(v_1, v_2))$}
    & Присваивание полям значений при условии, что $v_1$
    принадлежит множеству объектов QEMU, а $v_2$ множеству
    констант или множеству объектов QEMU \\
    \hline
    $[[<block>]](f_1,...,f_n) = field(f_1) \land ... \land field(f_n)$
    & Присваивание связанных с одной сущностью полей \\
    \hline
    $[[<python block>]](b) = assignment(B,B)$
    & Инициализация специального поля с Python-логикой\\
    \hline
\end{longtable}


\section{Поиск используемых сущностей QEMU}\label{sec:ch2/sec2}

Пробрасывание -- процесс преобразования и передачи данных между двумя интерфейсами.

Поиск используемых сущностей состоит в установлении типов QEMU для последующего
корректного пробрасывания их в логику устройства.
Также это необходимо для проверки корректности наследования и встраивания устройства.
Необходимыми для пробрасывания типами являются структуры и функции, оперирующие ими.

Рекурсивное преобразование структур QEMU в типы python важно для удобного и читаемого
использования C-объектов внутри python-логики.
Пробрасывание в python функций QEMU необходимо для использования уже имеющегося API эмулятора.
% TODO: может удалить, если это сложно
Потенциально, может быть удобным использование макросов препроцессора C внутри
логики Python.


\subsection*{Механизм использования информации о типах устройств}\label{sec:ch2/sec2/sub2/sub2}

Так как код QEMU насыщен использованием макросов, потребуется инструмент для их разворачивания -- препроцессор.
Чтобы не создавать собственную имплементацию препроцессора, этим будет заниматься препроцессор системного компилятора.

Практически во всех системах сборки программ в POSIX \cite{posix} окружении используется компилятор gcc или clang.
Оба компилятора являются совместимыми между собой. Для задействования препроцессора компилятора используется
опция \texttt{-E}. Так как препроцессор C, помимо раскрытия макросов занимается еще нахождением и подстановкой
заголовочных файлов, то потребуется указать папки с их местонахождением.
QEMU полагается на:
\begin{enumerate}[label={\arabic*)}]
    \item \label{build-header} заголовочные файлы, создаваемые в процессе сборки эмулятора;
    \item библиотеку GLib;
    \item заголовочные файлы, находящиеся в папке \texttt{include}.
\end{enumerate}

Так как файлы в пункте\cref{build-header} появляются в процессе сборки, то конкретную версию QEMU нужно будет собрать.
Сборка также полезна, так как в процессе конфигурации эмулятора выставляются определенные переменные
препроцессора (дефайны -- от директивы \texttt{\#define}), которые влияют на условные выражения
препроцессора, а те, в свою очередь, на генерацию исходного кода.
Использование в данном случае статического анализатора кода было бы затруднительным, так как
информация о конкретной конфигурации не может быть получена без непосредственной сборки.

Указание папки для препроцессора производится с помощью опции \texttt{-I}.
\begin{lstlisting}[caption={Пример строки запуска препроцессора для определенного файла устройства},
                   captionpos=b]
gcc -E hw/misc/edu.c
    -I ./include/
    -I ./build/
    -I/usr/include/glib-2.0
    -I/usr/lib64/glib-2.0/include
\end{lstlisting}


\section{Генерация python-интерфейса для логики устройства}\label{sec:ch2/sec2/sub3}

% TODO: как это вяжется со SWIG'ом?
Определение интерфейса используемых сущностей QEMU происходит в уже препроцессированном коде\cref{sec:ch2/sec2/sub2/sub2}.
Python, в эталонной реализации, является интерпретируемым языком программирования со сборщиком мусора.
Python спользует для сбора мусора подсчет ссылок и поколенческий сборщик мусора, чей API описан в модуле \texttt{gc}.
Уничтожение объектов, основанное на подсчете ссылок использует простое правило: если на объект больше
никто не ссылается, то память, занимаемая объектом, высвобождается.
Классическим недостатком данного подхода являются циклические ссылки: если объект \textit{A} ссылается
на объект \textit{B} (или же сам на себя), а тот, в свою очередь ссылается на объект \textit{A}, то система, основанная
только на подсчете ссылок, не может определить, реально ли используются оба этих объекта или нет.
В зависимости от языка, принимаются различные меры противодействия данной ситуации
(например Perl 5 никак не детектирует циклические ссылки между объектами,
из-за чего занимаемая ими память возвращается операционной системе только в момент завершения
работы интерпретатора).
В Python для решения данной проблемы используется поколенческий сборщик мусора (generational garbage collector),
который переодически запускается. Сборщик мусора выделяет три поколения объектов,
различающихся интервалами сканирования на предмет <<мусора>>:
\begin{itemize}
    \item первое поколение -- в него попадают все новые объекты;
    \item второе поколение -- если объект выжил после сборки мусора
        в первом поколении, то он перемещается во второе;
    \item третье поколение проверяется на наличие мусора только когда
        соотношение $\frac{\text{объекты, перемещаемые в верхнее поколение}}{\text{количество объектов второго и третьего поколения}} > 25\%$;
\end{itemize}

Тогда как поколенческий сборщик мусора можно отключить, подсчет ссылок нельзя, он ведется автоматически
для Python-кода и вручную C-кода с помощью макросов \texttt{Py\_INCREF} и \texttt{Py\_XINCREF}
увеличивают счетчик ссылок на объект, \texttt{Py\_DECREF} и \texttt{Py\_XDECREF}.
Разница между \texttt{X}-макросами и обычными состоит в том, что \texttt{X}-макросы
проверяют равенство передаваемого указателя \texttt{NULL}, из-за чего исполняются дольше.
Если указатель нулевой, то макрос ничего не делает.
Использование \texttt{Py\_DECREF} или \texttt{Py\_INCREF} на \texttt{NULL} приведет к ошибке во время исполнения.
Помимо этого нужно иметь в виду, что \texttt{Py\_DECREF} (и \texttt{Py\_XDECREF}) могут потенциально
привести к исполнению произвольного кода на Python, так как, в случае обнуления счетчика
ссылок у объектов, для которых определен деструктор (например освобождающий подключение к базе данных),
перед удалением объекта он будет вызван.


\subsection*{Генерация Python-интерфейса для C-кода}\label{sec:ch2/sec2/sub3/sub1}

Язык Python является скорее интерфейсом \cite{python-is-interface}, чем языком программирования:
документация описывает то, какие функции и конструкции должен предоставлять язык, чтобы являться Python'ом.
Подтверждением этому служит большое количество различных реализаций языка, например:
\begin{itemize}
    \item IronPython/Jython -- интерпретатор, работающий в CLR и JVM соответственно;
    \item PyPy -- JIT-интерпретатор, изначально написанный на самом Python;
    \item CPython \cite{cpython} -- эталонный интерпретатор Python, написанный на языке C;
\end{itemize}

Под языком Python практически всегда понимается интерпретатор CPython, как раз его
API для создания связки между кодом на C и Python и будет использоваться.

Для создания бесшовной интеграции, требуется:
\begin{itemize}
    \item преобразовывать C-структуры и C-функции в Python-объекты;
    \item оборачивать C-функции для конвертации Python-аргументов в C-типы;
    \item транслировать изменения связанных объектов внутри Python-кода.
\end{itemize}

\paragraph{SWIG} \cite{swig} --  Simplified Wrapper and Interface Generator.
Данное ПО позволяет автоматически генерировать обертки над C/C++ библиотеками для
большого спектра высокоуровневых языков программирования (\cref{fig:swig}).
Для этого требуется написать интерфейсный файл, в котором будут описаны шаблоны
функций и структур, для которых требуется сгенерировать интерфейс.
SWIG принимает на вход файл с описанием шаблонов для нахождения структур и
функций, которые будут экспортированы в межъязыковой интерфейс.
Несмотря на удобство, SWIG не обладает возможностями препроцессора и понимает
только ограниченное количество его директив, причем \texttt{define}'ы воспринимает
только если они объявляют константы.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={0.8\textwidth}{\textheight}}
        \includegraphics[]{images/swig.png}
    \end{adjustbox}
    \caption{Схема работы SWIG.}\label{fig:swig}
\end{figure}

Исходя из этого и того, что SWIG генерирует очень большое количество кода,
который все равно придется дополнять обращениями к C-API Python то логичнее
реализовать свое нахождение и преобразование C-сущностей.

Для этого используется пакет c-utils \cite{c-utils} для языка Racket \cite{racket}.
В нем реализован разбор грамматики, с учетом всех особенностей
языка: в C имеется два лексических класса, которые считаются
отличными в грамматике, но их использование идентично.
Это типы и их псевдонимы, задаваемые ключевым словом \texttt{typedef}.
Язык различает два этих класса по их связке с типом, поэтому
парсерам приходится поддерживать внутреннее окружение и предоставлять
его лексеру \cite{c-utils-internals}.

В Python существует несколько способов импорта C-сущностей:

\begin{enumerate}[label={\arabic*)}]
    \item \texttt{PyCapsule} -- позволяет инкапсулировать и передавать данные, находящиеся по некому указателю
          сквозь Python-код обратно в C. Сам Python не имеет доступа к инкапсулированному объекту
          так как не сохраняет никакой информации о типе. Ограничением в использовании \texttt{PyCapsule}
          является невозможность работы с данным объектом из многопоточного кода, так как
          Python не может его сериализовать;
    \item \texttt{memoryview} -- созданные объекты являются <<отображениями>> памяти, дают доступ
          к некоторому C-буферу, обозначенному при создании объекта. Можно использовать для
          экспорта сущностей, но с перекладыванием ответственности на интерпретацию байтов буфера
          на Python-код;
    \item Создание Python-объекта, отражающего C-сущность. Можно выполнить отдельным классом или
          же словарем.
\end{enumerate}

В {\mylanguage} для C-сущностей генерируются классы (\cref{fig:py-api-compilation}), отражающие их внутреннее устройство.
Объекты классов не имеют полей, и могут быть использованы только через оператор \texttt{[]}.
В пардигме Python, данный оператор является <<синтаксическим сахаром>> для вызова <<магических>>
функций \texttt{\_\_setitem\_\_} для выставления поля и \texttt{\_\_getitem\_\_} для получения значения.
В данном случае для \texttt{\_\_setitem\_\_} и \texttt{\_\_getitem\_\_} согласно C-API \cite{python-c-type-objects}
генерируются функции, которые первым делом производят конвертацию Python-типов в C-типы,
после чего уже возвращают или выставляют сконвертированные значения в структуры (листинг\cref{lst:python-c-type-objects}).

\begin{lstlisting}[caption={Пример доступа к элементу структуры из Python.},
                   captionpos=b,
                   language=python]
# вызывается функция __getitem__, которая по возможности
# конвертирует C-тип в Python-тип и возвращает Python-сущность,
# присваивая её переменной source.
source = EduState["dma_state"]["src"]

# вызывается функция __setitem__, которая по возможности
# конвертирует Python-тип в C-тип, после чего
# полю EduState.dma_state.dst присваивается значение.
EduState["dma_state"]["dst"] = source + 0x1234
\end{lstlisting}\label{lst:python-c-type-objects}

\begin{figure}[!htbp]
    \centering
    \hspace*{-11cm}
    \scalebox{0.8}{
        \begin{minipage}{10cm}
            \input{images/py-api-compilation.tikz}
        \end{minipage}
    }
    \caption{Схема алгоритма создания Python-сущностей для структур QEMU.}\label{fig:py-api-compilation}
\end{figure}

Создание функций, обращающихся к Python-логике тривиальнее, так как их создание следует
линейному алгоритму (\cref{fig:py-api-func-gen-algo-compilation}).

\begin{figure}[!htbp]
    \centering
    \input{images/py-api-func-gen-algo.tikz}
    \caption{Алгоритм генерации C-функции со связкой Python-логики.}\label{fig:py-api-func-gen-algo-compilation}
\end{figure}

Для улучшения человекочитаемости сгенерированного устройства, в код вставляются макросы с
частоиспользуемыми конструкциями (\cref{fig:py-api-func-compilation}).

\begin{figure}[!htbp]
    \centering
    \begin{adjustwidth*}{-1cm}{}
        \input{images/py-api-func-compilation.tikz}
    \end{adjustwidth*}
    \caption{Пример сгенерированной C-функции, связанной с Python-логикой.}\label{fig:py-api-func-compilation}
\end{figure}

\section{Генерация C-интерфейса устройства в QEMU}\label{sec:ch2/sec2/sub4}

Помимо генерации Python-интерфейса для согласования передачи данных между эмулятором
и логикой устройства, требуется соблюсти внутренний интерфейс QEMU для интеграции
модулей.

Как уже было сказано ранее\cref{sec:ch2/sec2/sub2}, аппаратное обеспечение регистрируется
в QEMU динамически, до исполнения функции \texttt{main}.
Для этого метаинформацией о создаваемом устройстве заполняется (возможно с помощью макроса)
структура \texttt{TypeInfo}, на основе которой создается и затем добавляется во внутреннюю
хэш-таблицу типов \texttt{TypeImpl}. Ключами в данной таблице являются имена типов
(поле \texttt{.name} \texttt{TypeInfo}), а значениями, соответственно, созданные \texttt{TypeImpl}.
Имена типов используются как для рефлексии -- во время исполнения программы можно узнать,
какое имя у объекта, и динамического преобразования типов.
Несмотря на то, что в C легко преобразовывать типы, в том числе и типы указателей, данный
механизм не имеет проверок правильности преобразования, в отличие, например, от
операции \texttt{dynamic\_cast} в языке C++.

Использование макросов в коде QEMU облегчает объявление технических структур,
унифицирует описания устройств, сокращает код, принуждает к программиста к использованию
единого стиля и иерархии, что положительно сказывается на конечном результате.
Также, использование макросов позволяет сильнее отвязать код от конкретной версии
QEMU.
Исходя из этого, алгоритм генерации, где это возможно, прибегает к использованию макросов,
нежели кодогенерации структур и функций.

\subsection*{Грамматика {\mylanguage} для создания устройств QEMU}\label{sec:ch2/sec2/sub4/sub1}

В грамматике языка {\mylanguage} 3 нетерминала:
\texttt{<device definition>}, \texttt{<device class inheritance>}, \texttt{<device class block>},
относятся к описанию класса QEMU-устройства, 1 -- \texttt{<python block>} к описанию Python-кода
и еще 1, \texttt{<bind block>} к связыванию Python-кода с C-кодом (см.\cref{sec:ch2/sec2/sub2}).

\texttt{<device definition>} объявляет тип создаваемого устройства, из которого автоматически
генерируются (\cref{fig:qemu-module-example}):
\begin{itemize}
    \item имя типа устройства -- CamelCase переводится в snake\_case;
    \item префикс для формирования имен функций устройства (в snake\_case);
    \item синоним типа устройства.
\end{itemize}

На этом этапе автоматически создаются прототипы функций для QOM, все
с префиксом типа устройства в snake\_case:
\begin{itemize}
    \item \texttt{class\_init} -- функция, инициализирующая класс устройства.
        Вызывается до старта \texttt{main}. Нужна для определения виртуальных методов.
        Так как в С нет поддержки уровня языка для создания виртуальных методов
        класса, то данный механизм реализован через поля структур, которые хранят
        указатели на функции. Присвоив к такому полю указатель на другую функцию
        с той же сигнатурой, произойдет, де-факто, переопределение виртуального метода.
        Вызывается после инициализации родительских классов;
    \item \texttt{instance\_init} -- функция-конструктор объекта. Вызывается после
        инициализации родительских классов;
    \item \texttt{instance\_post\_init} -- функция, опционально, завершающая инициализацию
        объекта. Вызывается только когда все \texttt{instance\_init} уже были вызваны;
    \item \texttt{instance\_finalize} -- функция-деструктор. Вызывается при уничтожении
        объекта. Вызывается до вызова аналогичной функции в родительском классе.
        Должна освобождать поля, уникальные только для своего типа;
\end{itemize}\label{enum:qemu-class-functions}

Логично описывать специализированную логику инициализации классов,
объектов QEMU, их конструкторов и деструкторов, как и всю остальную логику, в Python.
Поэтому, в случае, если программист в \texttt{<python block>} объявляет функции с именами,
соответствующими\cref{enum:qemu-class-functions}, данные Python-функции будут вызваны
в конце соответствующих C-функций, после прохождения необходимых инициализаций.
Если программисту хочется использовать другие Python-функции в иных контекстах,
данные Python-функций также описываются в блоке \texttt{<bind block>},
что <<экспортирует>> их в C: для каждой Python-функции создается C-функция,
которая оборачивает в себя подготовку и вызов непосредственно Python-функции, а так же
преобразование возвращаемого Python-функцией значения.


\begin{figure}[!htbp]
    \centering
    \hspace*{-10cm}
    \begin{minipage}{10cm}
        \input{images/qemu-module-example.tikz}
    \end{minipage}
    \caption{Пример сгенерированного QEMU-устройства}\label{fig:qemu-module-example}
\end{figure}

\texttt{<device class inheritance>} объявляет класс устройства и специфицирует
его родителя и, опционально, реализуемые устройством интерфейсы.
Классы в QEMU не поддерживают множественное наследование, так как
оно вносит слишком много сложностей при незначительных преимуществах.
Вместо этого, QEMU, как и многие современные объектно-ориентированные языки,
поддерживают механизм интерфейсов: пользователь интерфейса обязан реализовать
его, если наследуется от интерфейса. Причем сам интерфейс не содержит каких-либо
реализаций функций -- он является <<контрактом>>, позволяющим программисту гарантировать,
что у объекта будут реализованы функции, определенные интерфейсом.

\texttt{<device class block>} это совмещение \texttt{<device class inheritance>} и определения полей класса. В этом блоке объявляются типы
полей, сами поля инициализируются. Поддерживаются поля как простых типов, так и структур, объединений.

\section{Проброс ошибок QEMU из и в Python}\label{sec:ch2/sec2/sub5}
Парадигмы обработки и извещения об ошибках отличаются в Python и в C.
В C используется механизм возвращаемых значений, в Python -- исключения.
В некоторых проектах, например в загрузчике GRUB, с помощью макросов и
внутренних структур имитируется механизм исключений \cite{grub-error-handling}.
Заголовочный файл \texttt{errno.h} стандартной библиотеки C объявляет
коды ошибок, соответствующие им сообщения и одноименную переменную,
которая содержит в себе код последней ошибки.
Зачастую C-функции возвращают в качестве ошибки $-1$ или \texttt{NULL},
если функция работает с указателями или структурами.
Для некоторых функций такие возвращаемые значения могут являться корректными
и не означать, что произошла какая-либо ошибка.
В таком случае проверяется переменная \texttt{errno}, которая
является локальной для каждого потока.

В Python используется механизм исключений: вызываемая функция может <<бросить>> исключение определенного типа,
а вызывающая функция <<поймать>> его. Исключения являются более высокоуровневыми конструкциями, чем
коды возврата, позволяют добавить к самому исключению некоторое сообщение, а интерпретатор, в случае,
если исключение не <<поймано>>, выведет ошибку и укажет, где исключение было <<брошено>>.
Исключения распространяются вверх по стеку вызовов, в поиске обработчика, который может
обработать исключение данного типа, либо первого из родительских типов.
Из-за такого поиска <<бросание>> исключений становится дорогим в плане требуемых вычислений и
проигрывает коду, где код ошибки является возвращаемым значением.
Конструкция \texttt{try-except} в Python имеет опциональные ветвления:
\begin{itemize}
    \item \texttt{else}, если исключение не произошло;
    \item \texttt{finally}, вызывается в любом случае, в основном используется для очистки ресурсов.
\end{itemize}

Получить доступ ко всем классам Python-исключений из C-API просто -- они являются глобальными переменными.
Базовый класс всех исключений доступен по имени \texttt{PyExc\_Exception}.
Функция \texttt{PyErr\_Occured} позволяет узнать, происходило ли в Python необработанное исключение
впринципе, а \texttt{PyErr\_Fetch} получить три составляющих последнего исключения:
\begin{itemize}
    \item тип исключения;
    \item значение исключения (в основном строковые сообщения);
    \item трейсбек -- сохраненный стек вызовов на момент выбрасывания исключения.
\end{itemize}

В случае, если исключения нет, то все три значения будут \texttt{NULL}'ами,
причем, если исключение действительно было брошено, то значение
исключения и трейсбек могут быть \texttt{NULL}'ами (например исключение, произошедшее
в модуле C-расширения), так как являются опциональными.
\texttt{PyErr\_Restore}, в свою очередь, выставляет внутренний индикатор
исключений из перечисленных объектов.
Две данные функции используются в паре, если требуется запомнить исключение
перед исполнением и восстановить после завершения действий,
которые потенциально могут привести к возникновению новых исключений.

% Можно написать, как Python воспринимает ошибки из Си
Существует несколько способов из C-модуля бросить исключение в Python:
\begin{itemize}
    \item \texttt{PyErr\_SetString} -- получает аргументами тип исключения
        и сообщение, его описывающее;
    \item \texttt{PyErr\_SetFromErrno} -- получает тип исключения в качестве
        аргумента, а сообщение из переменной \texttt{errno};
    \item другие, более низкоуровневые функции, на которых основывается
        \texttt{PyErr\_SetString} и \texttt{PyErr\_SetFromErrno}.
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={0.8\textwidth}{\textheight}}
        \includegraphics[scale=1.5]{images/python_exception_hierarchy.png}
    \end{adjustbox}
    \caption{Иерархия исключений в Python.}\label{fig:python-exception-hierarchy}
\end{figure}

За любым неудачным выделением памяти должен следовать вызов \texttt{PyErr\_NoMemory},
бросающий в интерпретатор исключение о нехватке памяти.
Для игнорирования исключений вызванных функций, внутренний контейнер интерпретатора должен
быть явно очищен от исключения вызовом функции \texttt{PyErr\_Clear}.
Использоваться она должна только если вызывающая функция не хочет уведомлять интерпретатор
о произошедшем исключении и готова обработать его самостоятельно.

В случае, если исключение происходит в критически-важных функциях, вроде <<опознания>>
PCI-устройства, требуется корректно уведомить об этом QEMU.

\subsection*{Обработка Python-исключений в QEMU}\label{sec:ch2/sec2/sub5/sub1}

Все исключения внутри Python-логики должны быть обработаны. Если происходит
необработанное исключение внутри Python-кода, то функция \texttt{PyObject\_CallObject}
вернет \texttt{NULL} и выставит внутренний контейнер исключений.
В таком случае через \texttt{PyErr\_Fetch} будет получено сообщение произошедшего исключения,
на его основе будет вызвана функция \texttt{error\_setg} с ошибкой \texttt{error\_fatal},
которая корректно завершит работу QEMU.

\section{Компиляция Python-логики}\label{sec:ch2/sec3}

Python является интерпретируемым языком, но прежде чем выполниться,
код, компилируется в байт-код и уже потом исполняется на <<виртуальной машине>> Python.
Интерпретатор может оперировать в двух режимах: REPL и исполнение скриптов.
В первом случае, интерпретатор читает строка за строкой пользовательский
ввод, исполняя его как только сформируется корректная синтаксическая конструкция.
Во втором случае весь код, описанный в файле, первоначально компилируется в байткод и только потом исполняется
(\cref{fig:python-interpreter}).

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={0.8\textwidth}{\textheight}}
        \includegraphics[]{images/python-interpreter.png}
    \end{adjustbox}
    \caption{Схема работы интерпретатора Python.}\label{fig:python-interpreter}
\end{figure}

Так как {\mylanguage} создает модуль QEMU, не зависящий от сторонних файлов
на диске (чтобы скомпилированная QEMU могла работать в любом окружении),
код с Python-логикой помещается в отдельный заголовочный файл, в котором
создается строковая переменная, его содержащая.
Данная строковая переменная компилируется во время класса устройства,
с помощью функции \texttt{Py\_CompileString}, создавая Python-модуль,
после чего Python-модуль импортируется в интерпретатор
через \texttt{PyImport\_ExecCodeModule}, позволяя запрашивать уже у модуля
функции логики устройства (\cref{fig:qemu-python-startup}).

\begin{figure}[!htbp]
    \centering
    \hspace*{-11.5cm}
    \begin{minipage}{10cm}
        \input{images/qemu-python-startup.tikz}
    \end{minipage}
    \caption{Схема компиляции Python-логики устройства}\label{fig:qemu-python-startup}
\end{figure}


\section{Интеграция устройства в сборку QEMU}\label{sec:ch2/sec2/sub7}

После того, как файлы с исходным кодом устройства были сгенерированы, требуется
интегрировать устройство в сборку эмулятора QEMU (\cref{fig:qemu-compilation}).

Несмотря на то, что QEMU собирается meson'ом, в репозитории сохраняется
классический sh-скрипт конфигурации, вызвав который можно включить
или отключить компиляцию определенных устройств и возможностей QEMU.
Для добавления созданного устройства применяется шаблонизированный patch-файл,
в котором шаблонные значения препроцессируются и заменяются конкретными,
после чего patch накладывается на скрипт конфигурации.
Так как скрипт конфигурации постоянно и непредсказуемо может меняться,
то якорями для patch-файла являются неменяющийся код обработки ошибок
и добавление ключевых для компиляции QEMU библиотек (вроде GLib).

Скрипт конфигурации, который называется \texttt{configure} создается
файл \texttt{config-host.mak}, содержащий строки ключ-значение,
который загружается meson'ом и определяют, что именно добавлять в
результирующий исполняемый файл.

Так как логика устройства описана на языке Python, то интерпретатор Python
интегрируется в QEMU для ее исполнения, а компиляция устройства должна
проходить с соответствующими флагами. Для этого используется
скрипт, устанавливающийся вместе с Python -- \texttt{python3-config}.
Он позволяет запросить флаги для этапов компиляции (\texttt{--cflags})
и линковки (\texttt{--ldflags}) интерпретатора в программу.
Также используется флаг \texttt{--embed}, который указывает,
что Python на этапе будет встраиваться в программу.

\begin{figure}[!htbp]
    \centering
    \input{images/qemu-compilation.tikz}
    \caption{Схема интеграции созданного устройства в QEMU.}\label{fig:qemu-compilation}
\end{figure}


\section*{Выводы по главе}\label{sec:ch2/sec4}\addcontentsline{toc}{section}{Выводы по главе}

Сформулирован подход к решению задачи создания виртуального аппаратного обеспечения.

Представлено формализованное представление задачи
создания виртуального аппаратного обеспечения.

Описана грамматика (расширения форма Бэкуса-Наура) и семантика (денотационная) разрабатываемого языка.

Описан механизм поиска используемых сущностей QEMU, преобразование
ошибок между QEMU и Python.

Описана генерация Python-интерфейса для логики виртуального аппаратного обеспечения и
генерация C-интерфейса для встраивания разрабатываемого виртуального аппаратного
обеспечения в объектную модель QEMU (QOM).

