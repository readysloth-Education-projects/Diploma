\chapter{Конструкторский раздел}\label{ch:ch2}
\section{Обоснование выбора языка программирования и среды разработки}\label{sec:ch2/sec1}

Для разработки {\ProgModule} понадобится сверхвысокоуровневый язык с кросс-платформенной
стандартной библиотекой, который позволит точно и лаконично описать этапы анализа,
а так же имеющий высокую скорость исполнения, для анализа больших объемов исходного кода и
исполняемых файлов.

{\small
    \setlength{\tabcolsep}{2pt}
    \begin{longtable}{*{5}{| c}|}
        \hline
        \diagbox[width=8cm]{Свойства}{Язык программирования} &
            \makecell{Nim \autocite{nim}} &
            \makecell{Python \autocite{python}} &
            \makecell{Perl \autocite{perl}} &
            \makecell{C/C++} \\
        \hline
            \makecell{Сверхвысокоуровневость} & 
            \greencell{Да} & 
            \greencell{Да} &
            \greencell{Да} &
            \redcell{Нет} \\
        \hline
            \makecell{Компилируется в\\машинный код} & 
            \greencell{Да} & 
            \redcell{Нет} &
            \redcell{Нет} &
            \greencell{Да} \\
        \hline
            \makecell{Количество функции в\\стандартной библиотеке} & 
            5585 & 
            638 &
            1338 &
            1224 \\
        \hline
            \makecell{Портируемость} & 
            \greencell{Есть} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \yellowcell{\makecell{Есть,\\но неудобная}}\\
        \hline
            \makecell{Встроенная\\генерация документации} & 
            \greencell{Есть} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \redcell{Нет}\\
        \hline
            \makecell{Статическая типизация} & 
            \greencell{Есть} & 
            \redcell{Нет} &
            \redcell{Нет} &
            \greencell{Есть}\\
        \hline
            \makecell{Автоматическое\\управление памятью} & 
            \greencell{Есть} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} \\
        \hline
            \makecell{Обобщенное программирование} & 
            \greencell{Есть} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} \\
        \hline
            \makecell{Опыт использования} & 
            \greencell{Есть} & 
            \greencell{Есть} &
            \redcell{Нет} &
            \greencell{Есть} \\
        \hline
    \caption{\label{table:languages-comparsion}
           Сравнительная таблица языков программирования}
    \end{longtable}
}

Рассмотрим подробно каждый из представленных в таблице языков:
\begin{itemize}
    \item C++ -- мультипарадигменный высокоуровневый язык программирования,
        разработанный в 1983 году Бьёрном Страуструпом. Является практически
        полным надмножеством языка C. Статически типизирован.\\
        Отличается высокой производительностью и неплохой гибкостью при написании кода.
        К минусам языка можно отнести сложность освоения и перегруженность 
        <<наследием>> 80-х годов прошлого века, а так же низкую скорость компиляции,
        по сравнению с предшественником -- C.\\
        Портируемость языка на различные платформы обеспечивается пере- или
        кросс-компиляцией исходного кода под нужную платформу.
        

    \item Python \autocite{python} -- мультипарадигменный сверхвысокоуровневый 
        язык программирования, разработанный в 1991 году Гвидо Ван Россумом.
        Является интерпретируемым языком, имеет слабую динамическую типизацию,
        что позволяет легко писать обобщенный код и использовать мета-программирование,
        но так же ведет к трудноулавливаемым ошибкам. Негативное влияние можно сгладить
        с помощью указания типов при объявлении перемнных и аргументов функций, а так же 
        программы, проверяющей эти типы -- линтера. Например pylint \autocite{pylint} или
        pyflakes \autocite{pyflakes}.\\
        Благодаря своей популярности, python так же портирован на большое количество платформ.
        Большим плюсом языка является его обширная стандартная библиотека, позволяющая легко
        писать комплексные приложения, не прибегая к установке дополнительных библиотек --
        такие программы, как и сам python, следуют философии <<в комплекте с батарейками>>
        (<<batteries included>> \autocite{batteries-included}), суть которой заключается в 
        самодостаточности программ. Помимо этого вместе с python поставляется менеджер
        пакетов pip \autocite{pip}, позволяющий удобно устанавливать требуемые библиотечные модули вместе
        с зависимостями.\\
        К минусам языка можно отнести медлительность эталонного интерпретатора языка -- cpython \autocite{cpython}.
        Код, исполняемый им, в определенных задачах медленнее кода на C в сотни раз. Не смотря на то, что
        есть более быстрые интерпретаторы: PyPy \autocite{pypy}, Jython \autocite{jython}, Iron Python \autocite{iron-python},
        они не смогут достичь скорости исполнения программ, компилируемых в машинный код.\\
        На данный момент существует две, между собой несовместимые, версии языка: 
        python 2, поддержка которого закончилась \DTMdate{2020-01-01} и python 3.

    \item Perl \autocite{perl} -- мультипарадигменный сверхвысокоуровневый 
        язык программирования, разработанный в 1987 году Ларри Уоллом.
        Является интерпретируемым языком, имеет слабую динамическую типизацию.\\
        Полное название языка -- <<Practical Extraction and Report Language>> 
        (<<Практический Язык для Извлечения Данных и Составления Отчётов>>), отражает его суть:
        в языке реализованы обширные возможности для работы с текстом, в синтаксис интегрированы 
        регулярные выражения, как и в языках, которые оказали на него наибольшее влияние --
        AWK \autocite{awk} и sed \autocite{sed}. Но это же и я является его слабой частью, так как
        Perl скорее предназначен для однострочных команд в терминале, как AWK \autocite{awk} и
        sed \autocite{sed}.
        
    \item Nim \autocite{nim} -- мультипарадигменный сверхвысокоуровневый 
        язык программирования, разработанный в 2004 году Андреасом Румпфом.
        Является компилируемым языком, имеет строгую статическую типизацию.\\
        Заметно, что на синтаксис языка повлиял Python, что сделало его
        выразительным и понятным. Язык использует промежуточную компиляцию, которая несколько
        замедляет процесс компиляции программ, но позволяет запускать nim-программы на различных
        платформах. На данный момент поддерживается компиляция в JavaScript \autocite{javascript}
        и оптимизированный C-код с несколькими моделями управления памятью:\\
        \begin{itemize}
            \item Сборщики мусора, основанные на:
                \begin{enumerate}
                    \item Подсчете ссылок
                    \item Подсчет ссылок с оптимизацией move-семантикой \autocite{nim-gc-move}
                    \item Boehm \autocite{boehm-gc}
                    \item Go \autocite{go-gc}
                \end{enumerate}
            \item Ручном освобождении памяти
            \item Модель, в которой вся выделенная память высвобождается только по завершению программы
                (не рекомендуется к использованию)
        \end{itemize}
        Компиляции Nim в C, означает не только высокую скорость работы, но и прозрачный программный интерфейс при взаимодействии с
        C библиотеками. Это значит, что можно писать Nim-код, взаимодействующий с С библиотекой так же, как
        если бы это была Nim-библиотека, в отличие от, например, Python.\\
        Так же вместе с компилятором языка поставляется пакетный менеджер nimble \autocite{nimble} и генератор
        документации из комментариев, написанных на reStructuredText \autocite{restructuredtext}.

\end{itemize}

\textbf{Вывод:} Из всего вышесказанного следует, что для {\ProgModule} лучше всего подойдет язык Nim
благодаря его скорости, выразительности и портируемости на различные платформы.
Кроме того, для подготовки динамического анализа программы будут использованы утилиты, умеющие разбирать
заголовки исполняемого файла, а именно objdump и readelf. Форматирование входных данных для данных утилит
будет осуществляться с помощью Bash-скриптов.

\section{Обоснование выбора среды разработки}\label{sec:ch2/sec2}

Для разработки на Nim существует несколько IDE и огромное количество
текстовых редакторов, часть которых рассмотрим ниже:

{\small
    \setlength{\tabcolsep}{2pt}
    \begin{longtable}{*{6}{| c}|}
        \hline
        \diagbox[width=8cm]{Свойства}{IDE/Редактор} &
            \makecell{Aporia \autocite{aporia-ide}} &
            \makecell{Atom \autocite{atom-ide}} &
            \makecell{Sublime\\Text \autocite{sublime-ide}} &
            \makecell{Visual\\Studio\\Code \autocite{vs-code-ide}} &
            \makecell{Vim \autocite{vim-ide}} \\
        \hline
            \makecell{Поддержка плагинов} & 
            \redcell{Нет} &
            \greencell{Да} & 
            \greencell{Да} &
            \greencell{Да} &
            \greencell{Да} \\
        \hline
            \makecell{Требователен к ресурсам} & 
            \greencell{Нет} & 
            \redcell{Да} & 
            \greencell{Нет} & 
            \redcell{Да} & 
            \greencell{Нет} \\ 
        \hline
            \makecell{Имеет продвинутую систему\\редактирования текста} & 
            \redcell{Нет} &
            \redcell{Нет} &
            \redcell{Нет} &
            \redcell{Нет} &
            \greencell{Да} \\
        \hline
            \makecell{Кросс-платформенность} & 
            \greencell{Есть} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} \\
        \hline
            \makecell{Может работать\\без GUI} & 
            \redcell{Нет} &
            \redcell{Нет} &
            \redcell{Нет} &
            \redcell{Нет} &
            \greencell{Да} \\
        \hline
            \makecell{Восстановление после сбоев} & 
            \redcell{Нет} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} \\
        \hline
            \makecell{Возможность выделять\\ключевые слова с помощью\\регулярных выражений} & 
            \redcell{Нет} & 
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} \\
        \hline
            \makecell{Опыт использования} & 
            \redcell{Нет} &
            \redcell{Нет} &
            \greencell{Есть} &
            \greencell{Есть} &
            \greencell{Есть} \\
        \hline
    \caption{\label{table:ide-comparsion}
           Сравнительная таблица IDE и редакторов кода}
    \end{longtable}
}

Рассмотрим подробно каждый из представленных в таблице редакторов:
\begin{itemize}
    \item Aporia -- простая IDE, написанная на nim, с использованием GTK2.
        В настоящее время не поддерживается, так как большая часть Nim-программистов
        перешла на Visual Studio Code.

    \item Atom -- редактор от GitHub Inc., написан с использованием Electron \autocite{electron} -- фреймворка
        для разработки кросс-платформенных приложений с помощью HTML, JavaScript и CSS. Из-за архитектурных
        и технологических решений, все программы, написанные на данном фреймворке, будут очень требовательны
        к ресурсам.

    \item Sublime Text -- проприетарный текстовый редактор, возможности которого могут быть расширены
        с помощью плагинов на python.

    \item Visual Studio Code -- редактор от Microsoft. Так же, как и Atom, написан с использованием Electron.

    \item Vim -- текстовый редактор с открытым исходным кодом и большими возможностями к
        быстрому редактированию текстов. Является наследником редактора vi, который, в свою
        очередь, создавался с оглядкой на редактор ed. Управление делится на
        режим ввода и режим команд, благодаря чему есть возможность управлять 
        редактором только с помощью клавиатуры, что, при должном умении, повышает скорость
        не только из-за отсутствия необходимости в использовании компьютерной мыши, но и
        более коротким сочетаниям  <<горячих клавиш>>. Легко поддается модифицированию с помощью плагинов.
        Есть под множество платформ.

\end{itemize}

\textbf{Вывод:} Из всего вышесказанного и личного опыта следует, 
что для разработки {\ProgModule} лучше всего подойдет текстовый редактор Vim,
так как он поддерживает добавление плагинов, не требователен к ресурсам и позволяет
очень быстро редактировать текст.

\newpage

\section{Организация передачи информации между компонентами {\ProgModule}}\label{sec:ch2/sec3}
Передача информации между компонентами {\ProgModule} осуществляется посредством
сериализации внутренних структур конкретного модуля в формате JSON.
JSON удобен тем, что является простым для чтения как человеком, так и компьютером,
что позволяет оператору анализировать так же и промежуточные результаты работы, для
вынесения вердикта.

\section{Cхема данных}\label{sec:ch2/sec4}

\begin{figure}[!htbp]
    \centerfloat{
        \input{images/dataflow.tikz}
    }
    \caption{Схема данных {\ProgModule}\label{fig:dataflow}}
\end{figure}
Из схемы данных \autoref{fig:dataflow} видно, что работу {\ProgModule} можно разбить на параллельные 
задачи.


\section{Алгоритм работы программы}\label{sec:ch2/sec5}
Работу {\ProgModule} можно разделить на функциональные этапы:
\begin{enumerate}
    \item Сборка анализиуемой программы 
    \item Статический анализ результатов сборки\label{statical-analysis-stage}
    \item Динамический анализ собранной программы\label{dynamical-analysis-stage}
    \item Сравнительный анализ результатов предыдущих шагов
\end{enumerate}

Причем \autoref{statical-analysis-stage} и \autoref{dynamical-analysis-stage} могут выполняться
одновременно, так как не имеют зависимости по данным.

\begin{figure}[!htbp]
    \centerfloat{
        \input{images/algorithm.tikz}
    }
    \caption{Алгоритм работы {\ProgModule}\label{fig:algorithm}}
\end{figure}

