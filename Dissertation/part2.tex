\chapter{Конструкторский раздел}\label{ch:ch2}
\section{Обоснование выбора языка программирования}\label{sec:ch2/sec1}

\subsection{Сравнение языков программирования}\label{sec:ch2/sec1/sub1}
Для разработки {\ProgModule} понадобится сверхвысокоуровневый язык с кросс-платформенной
стандартной библиотекой, который позволит точно и лаконично описать этапы анализа,
а так же имеющий высокую скорость исполнения, для анализа больших объемов исходного кода и
исполняемых файлов.

\begin{table}
    {\small
        \setlength{\tabcolsep}{2pt}
        \caption{\label{table:languages-comparsion}
               Сравнительная таблица языков программирования}
        \begin{longtable}{*{5}{| c}|}
            \hline
            \diagbox[width=8cm]{Свойства}{Язык программирования} &
                \makecell{Nim \autocite{nim}} &
                \makecell{Python \autocite{python}} &
                \makecell{Perl \autocite{perl}} &
                \makecell{C/C++} \\
            \hline
                \makecell{Сверхвысокоуровневость} & 
                \greencell{Да} & 
                \greencell{Да} &
                \greencell{Да} &
                \redcell{Нет} \\
            \hline
                \makecell{Компилируется в\\машинный код} & 
                \greencell{Да} & 
                \redcell{Нет} &
                \redcell{Нет} &
                \greencell{Да} \\
            \hline
                \makecell{Количество функции в\\стандартной библиотеке} & 
                5585 & 
                638 &
                1338 &
                1224 \\
            \hline
                \makecell{Портируемость} & 
                \greencell{Есть} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \yellowcell{\makecell{Есть,\\но неудобная}}\\
            \hline
                \makecell{Встроенная\\генерация документации} & 
                \greencell{Есть} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \redcell{Нет}\\
            \hline
                \makecell{Статическая типизация} & 
                \greencell{Есть} & 
                \redcell{Нет} &
                \redcell{Нет} &
                \greencell{Есть}\\
            \hline
                \makecell{Автоматическое\\управление памятью} & 
                \greencell{Есть} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} \\
            \hline
                \makecell{Обобщенное программирование} & 
                \greencell{Есть} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} \\
            \hline
                \makecell{Опыт использования} & 
                \greencell{Есть} & 
                \greencell{Есть} &
                \redcell{Нет} &
                \greencell{Есть} \\
            \hline
        \end{longtable}
    }
\end{table}

Рассмотрим подробно каждый из представленных в таблице языков.

\subsubsection{C++}\label{sec:ch2/sec1/sub1/sub1}
Мультипарадигменный высокоуровневый язык программирования,
разработанный в 1983 году Бьёрном Страуструпом. Является практически
полным надмножеством языка C. Статически типизирован.\\
Отличается высокой производительностью и неплохой гибкостью при написании кода.
К минусам языка можно отнести сложность освоения и перегруженность 
<<наследием>> 80-х годов прошлого века, а так же низкую скорость компиляции,
по сравнению с предшественником -- C.\\
Портируемость языка на различные платформы обеспечивается пере- или
кросс-компиляцией исходного кода под нужную платформу.


\subsubsection{Python}\label{sec:ch2/sec1/sub1/sub2}
Мультипарадигменный сверхвысокоуровневый язык программирования,
разработанный в 1991 году Гвидо Ван Россумом.
Является интерпретируемым языком, имеет слабую динамическую типизацию,
что позволяет легко писать обобщенный код и использовать мета-программирование,
но так же ведет к трудноулавливаемым ошибкам. Негативное влияние можно сгладить
с помощью указания типов при объявлении перемнных и аргументов функций, а так же 
программы, проверяющей эти типы -- линтера. Например pylint \autocite{pylint} или
pyflakes \autocite{pyflakes}.\\
Благодаря своей популярности, python так же портирован на большое количество платформ.
Большим плюсом языка является его обширная стандартная библиотека, позволяющая легко
писать комплексные приложения, не прибегая к установке дополнительных библиотек --
такие программы, как и сам python, следуют философии <<в комплекте с батарейками>>
(<<batteries included>> \autocite{batteries-included}), суть которой заключается в 
самодостаточности программ. Помимо этого вместе с python поставляется менеджер
пакетов pip \autocite{pip}, позволяющий удобно устанавливать требуемые библиотечные модули вместе
с зависимостями.\\
К минусам языка можно отнести медлительность эталонного интерпретатора языка -- cpython \autocite{cpython}.
Код, исполняемый им, в определенных задачах медленнее кода на C в сотни раз. Не смотря на то, что
есть более быстрые интерпретаторы: PyPy \autocite{pypy}, Jython \autocite{jython}, Iron Python \autocite{iron-python},
они не смогут достичь скорости исполнения программ, компилируемых в машинный код.\\
На данный момент существует две, между собой несовместимые, версии языка: 
python 2, поддержка которого закончилась \DTMdate{2020-01-01} и python 3.

\subsubsection{Perl}\label{sec:ch2/sec1/sub1/sub2}
Мультипарадигменный сверхвысокоуровневый 
язык программирования, разработанный в 1987 году Ларри Уоллом.
Является интерпретируемым языком, имеет слабую динамическую типизацию.\\
Полное название языка -- <<Practical Extraction and Report Language>> 
(<<Практический Язык для Извлечения Данных и Составления Отчётов>>), отражает его суть:
в языке реализованы обширные возможности для работы с текстом, в синтаксис интегрированы 
регулярные выражения, как и в языках, которые оказали на него наибольшее влияние --
AWK \autocite{awk} и sed \autocite{sed}. Но это же и я является его слабой частью, так как
Perl скорее предназначен для однострочных команд в терминале, как AWK и
sed.
        
\subsubsection{Nim}\label{sec:ch2/sec1/sub1/sub3}
Мультипарадигменный сверхвысокоуровневый 
язык программирования, разработанный в 2004 году Андреасом Румпфом.
Является компилируемым языком, имеет строгую статическую типизацию.\\
Заметно, что на синтаксис языка повлиял Python, что сделало его
выразительным и понятным. Язык использует промежуточную компиляцию, которая несколько
замедляет процесс компиляции программ, но позволяет запускать nim-программы на различных
платформах. На данный момент поддерживается компиляция в JavaScript \autocite{javascript}
и оптимизированный C-код с несколькими моделями управления памятью:\\
\begin{itemize}
    \item Сборщики мусора, основанные на:
        \begin{enumerate}
            \item подсчете ссылок;
            \item подсчете ссылок с оптимизацией move-семантикой \autocite{nim-gc-move}:
            \item boehm \autocite{boehm-gc};
            \item go \autocite{go-gc};
        \end{enumerate}
    \item ручном освобождении памяти;
    \item модель, в которой вся выделенная память высвобождается только по завершению программы;
        (не рекомендуется к использованию)
\end{itemize}
Компиляции Nim в C означает не только высокую скорость работы, но и прозрачный программный интерфейс при взаимодействии с
C библиотеками. Это значит, что можно писать Nim-код, взаимодействующий с С библиотекой так же, как
если бы это была Nim-библиотека, в отличие от, например, Python.\\
Так же вместе с компилятором языка поставляется пакетный менеджер nimble \autocite{nimble} и генератор
документации из комментариев, написанных на reStructuredText \autocite{restructuredtext}.

\subsubsection{Вывод}\label{sec:ch2/sec1/sub1/sub4}
Из всего вышесказанного следует, что для {\ProgModule} лучше всего подойдет язык Nim
благодаря его скорости, выразительности и портируемости на различные платформы.
Кроме того, для подготовки динамического анализа программы будут использованы утилиты, умеющие разбирать
заголовки исполняемого файла, а именно objdump и readelf. Форматирование входных данных для данных утилит
будет осуществляться с помощью Bash-скриптов.

\subsection{Обоснование выбора среды разработки}\label{sec:ch2/sec1/sub2}

\subsection{Сравнение сред разработки}\label{sec:ch2/sec1/sub1}

Для разработки на Nim существует несколько IDE и огромное количество
текстовых редакторов, часть которых рассмотрим ниже:

\begin{table}[!htbp]
    {\small
        \setlength{\tabcolsep}{2pt}
        \caption{\label{table:ide-comparsion}
               Сравнительная таблица IDE и редакторов кода}
        \begin{longtable}{*{6}{| c}|}
            \hline
            \diagbox[width=8cm]{Свойства}{IDE/Редактор} &
                \makecell{Aporia \autocite{aporia-ide}} &
                \makecell{Atom \autocite{atom-ide}} &
                \makecell{Sublime\\Text \autocite{sublime-ide}} &
                \makecell{Visual\\Studio\\Code \autocite{vs-code-ide}} &
                \makecell{Vim \autocite{vim-ide}} \\
            \hline
                \makecell{Поддержка плагинов} & 
                \redcell{Нет} &
                \greencell{Да} & 
                \greencell{Да} &
                \greencell{Да} &
                \greencell{Да} \\
            \hline
                \makecell{Требователен к ресурсам} & 
                \greencell{Нет} & 
                \redcell{Да} & 
                \greencell{Нет} & 
                \redcell{Да} & 
                \greencell{Нет} \\ 
            \hline
                \makecell{Имеет продвинутую систему\\редактирования текста} & 
                \redcell{Нет} &
                \redcell{Нет} &
                \redcell{Нет} &
                \redcell{Нет} &
                \greencell{Да} \\
            \hline
                \makecell{Кросс-платформенность} & 
                \greencell{Есть} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} \\
            \hline
                \makecell{Может работать\\без GUI} & 
                \redcell{Нет} &
                \redcell{Нет} &
                \redcell{Нет} &
                \redcell{Нет} &
                \greencell{Да} \\
            \hline
                \makecell{Восстановление после сбоев} & 
                \redcell{Нет} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} \\
            \hline
                \makecell{Возможность выделять\\ключевые слова с помощью\\регулярных выражений} & 
                \redcell{Нет} & 
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} \\
            \hline
                \makecell{Опыт использования} & 
                \redcell{Нет} &
                \redcell{Нет} &
                \greencell{Есть} &
                \greencell{Есть} &
                \greencell{Есть} \\
            \hline
        \end{longtable}
    }
\end{table}

Рассмотрим подробно каждый из представленных в таблице редакторов.

\subsubsection{Aporia}\label{sec:ch2/sec1/sub2/sub1}
Простая IDE, написанная на nim, с использованием GTK2.
В настоящее время не поддерживается, так как большая часть Nim-программистов
перешла на Visual Studio Code.

\subsubsection{Atom}\label{sec:ch2/sec1/sub2/sub2}
Редактор от GitHub Inc., написан с использованием Electron \autocite{electron} -- фреймворка
для разработки кросс-платформенных приложений с помощью HTML, JavaScript и CSS. Из-за архитектурных
и технологических решений, все программы, написанные на данном фреймворке, будут очень требовательны
к ресурсам.

\subsubsection{Sublime Text}\label{sec:ch2/sec1/sub2/sub3}
Проприетарный текстовый редактор, возможности которого могут быть расширены
с помощью плагинов на python.

\subsubsection{Visual Studio Code}\label{sec:ch2/sec1/sub2/sub4}
Редактор от Microsoft. Так же, как и Atom, написан с использованием Electron.
Имеет встроенный <<магазин>> плагинов.

\subsubsection{Vim}\label{sec:ch2/sec1/sub2/sub5}
Текстовый редактор с открытым исходным кодом и большими возможностями к
быстрому редактированию текстов. Является наследником редактора vi, который, в свою
очередь, создавался с оглядкой на редактор ed. Управление делится на
режим ввода и режим команд, благодаря чему есть возможность управлять 
редактором только с помощью клавиатуры, что, при должном умении, повышает скорость
не только из-за отсутствия необходимости в использовании компьютерной мыши, но и
более коротким сочетаниям  <<горячих клавиш>>. Легко поддается модифицированию с помощью плагинов.
Есть под множество платформ.


\subsubsection{Вывод}\label{sec:ch2/sec1/sub1/sub4}
Из всего вышесказанного и личного опыта следует, 
что для разработки {\ProgModule} лучше всего подойдет текстовый редактор Vim,
так как он поддерживает добавление плагинов, не требователен к ресурсам и позволяет
очень быстро редактировать текст. В качестве расширения его функциональности использованы
плагины:
\begin{enumerate}
    \item NERDTree \autocite{nerdtree} -- улучшает просмотр каталогов;
    \item Tabular \autocite{tabular} -- позволяет быстро выравнивать текст
        для улучшения читаемости.
    \item vim-polyglot \autocite{vim-polyglot} -- подсветка синтаксиса большого
        числа языков
    \item undotree \autocite{undotree} -- просмотр истории изменений в виде дерева
    \item rainbow \autocite{rainbow} -- подсветка вложенных скобок разными цветами,
        для улучшения читаемости
\end{enumerate}


\begin{figure}[!htbp]
    \centerfloat{
        \includegraphics[width=\linewidth]{images/Vim.png}
    }
    \caption{Интерфейс Vim {\ProgModule}\label{fig:vim-tui}}
\end{figure}

\section{Архитектура {\ProgModule}}\label{sec:ch2/sec4}
Архитектура программного обеспечения это система, объединяющая внутрение
компоненты, их связи между собой и с окружением, а так же принципы,
использующиеся при проектировании и эволюции программы \autocite{software-architecture}.

При проектировании {\ProgModule} была выбрана UNIX-философия \autocite{unix-philosophy},
заключающаяся в следующих основопологающих принципах:
\begin{itemize}
    \item создавать маленькие программы;
    \item программы делают одно дело, но делают его хорошо;
    \item хранить данные в текстовом, читаемом для людей формате;
\end{itemize}

Поэтому было принято решение разрабатывать под каждую подзадачу проведения сертификации ПО
самостоятельную программу, которая была бы маленькой и хорошо бы справлялась со своим назначением.

\subsection{Организация передачи информации между компонентами {\ProgModule}}\label{sec:ch2/sec4/sub1}
Передача информации между компонентами {\ProgModule} осуществляется посредством
сериализации внутренних структур конкретного модуля в формате JSON.
JSON удобен тем, что является простым для чтения как человеком, так и компьютером,
что позволяет оператору анализировать так же и промежуточные результаты работы, для
вынесения вердикта.

\subsubsection{Виды сериализуемых данных}\label{sec:ch2/sec4/sub1/sub1}
В {\ProgModule} сериализуются данные после прохождения этапа:
\begin{itemize}
    \item статического анализа исходных кодов;
    \item динамического анализа сертифицируемой программы;
\end{itemize}

\begin{figure}[!htbp]
    \centerfloat{
        \input{images/dynamic_json.tikz}
    }
    \caption{Сохраняемые структуры динамического анализа \label{fig:dynamic-json}}
\end{figure}

Структура данных помогает иерархически организовать доступ к собранной, во время
динамического анализа, информации.

\texttt{BreakpointInfo} содержит данные с расставленных точек останова, получаемые 
непосредственно во время выполнения машинных инструкций программы, а значит важно
в них получить максимальное количество информации текущем мгновенном состоянии программы.
В структуре содержится:
\begin{itemize}
    \item адреса:
            \begin{itemize}
                \item \texttt{call} инструкции, на которой находится точка останова
                \item по которому собирается сделать вызов \texttt{call} инструкция
                \item функции, в котором находится данная \texttt{call} инструкция
            \end{itemize}
            Которые необходимы для последующего сравнительного анализа;
        \item регистры, в которых могут содержаться передаваемые параметры (fastcall convention \autocite{fastcall});
        \item следующие за \texttt{call} 8 инструкций, в которых может содержаться код, обрабатывающий
            возвращенное значение;
        \item стек вызовов, позволяет посмотреть ветку исполнения исследуемой программы
\end{itemize}

Информация о сегментах в \texttt{SegmentInfo} позволяет определить, к какому сегменту относится
вызываемая, или текущая функция. Например, это может быть сегмент динамически загружаемой библиотеки.

\texttt{FunctionInfo} содержит информацию, которую предоставляет GDB при загрузке программы:
список известных функций и их адреса. Полезно для анализа

\texttt{ProcessStartInfo} сохраняет параметры запуска, \texttt{ProcessSegmentsInfo} -- 
агрегирует информацию по всем сегментам программы.

Структура \texttt{Process} же агрегирует в себе всё вышеперечисленное 

\begin{figure}[!htbp]
    \centerfloat{
        \input{images/static_json.tikz}
    }
    \caption{Сохраняемые структуры статического анализа \label{fig:static-json}}
\end{figure}


\subsection{Cхема данных}\label{sec:ch2/sec4/sub2}

\begin{figure}[!htbp]
    \centerfloat{
        \input{images/dataflow.tikz}
    }
    \caption{Схема данных {\ProgModule}\label{fig:dataflow}}
\end{figure}
Из схемы данных \autoref{fig:dataflow} видно, что работу {\ProgModule} можно разбить на параллельные 
задачи.

\subsection{Алгоритм работы программы}\label{sec:ch2/sec4/sub3}
Работу {\ProgModule} можно разделить на функциональные этапы:
\begin{enumerate}
    \item сборка анализиуемой программы;
    \item статический анализ результатов сборки\label{statical-analysis-stage};
    \item динамический анализ собранной программы\label{dynamical-analysis-stage};
    \item сравнительный анализ результатов предыдущих шагов;
\end{enumerate}

Причем \autoref{statical-analysis-stage} и \autoref{dynamical-analysis-stage} могут выполняться
одновременно, так как не имеют зависимости по данным.

\begin{figure}[!htbp]
    \centerfloat{
        \input{images/algorithm.tikz}
    }
    \caption{Алгоритм работы {\ProgModule}\label{fig:algorithm}}
\end{figure}

