\chapter{Формализация процесса создания эмуляторов аппаратного обеспечения}\label{ch:ch2}

Помимо сказанного в главе \ref{sec:ch1/sec4} для создании эмуляторов аппаратного обеспечения
требуется формализовать данную задачу.

\section{Подход}\label{sec:ch2/sec1}

Подход к решению обозначенных проблем будет основываться на эмуляторе QEMU и его
возможности встраивать пользовательские устройства.
Для этого необходимо:

\begin{enumerate}[label={\arabic*)}]
    \item \label{q-inh} проанализировать цепочки наследования сущностей QOM;
    \item \label{q-inh-scheme} составить схему наследования сущностей;
    \item \label{q-interface} определить интерфейс взаимодействия эмулятора с выделенными сущностями;
    \item \label{q-impl} реализовать устройство;
\end{enumerate}

Корректность выполнения пунктов \ref{q-inh}-\ref{q-interface} должна полностью брать на себя разрабатываемая система,
тогда как вместо предоставления автосгенерированного файла с исходным кодом \ref{sec:ch1/sec2} для
последующей модификации, результатом выполнения пункта \ref{q-impl} должен быть готовый к встраиванию
файл с исходным кодом, не требующий ручной модификации.
Для этого требуется проблемно-ориентированный язык, компиляция которого, помимо генерации шаблонного кода
создаст интерфейс передачи объектов между C-устройством внутри QEMU и интерпретатором Python, в
котором будет исполняться реализованная логика работы устройства.

С учетом всего вышесказанного, На рис. \ref{fig:device-compilation} показана функциональная схема преобразования
описания виртуального устройства в часть эмулятора QEMU.

\begin{figure}[!htbp]
    \centering
    \input{images/func-scheme.tikz}
    \caption{Функциональная схема компиляции виртуального устройства.}\label{fig:device-compilation}
\end{figure}


\subsection{Язык описания виртуального устройства}\label{sec:ch2/sec1/sub1}

Использование специализированного языка для описания устройства, в отличие от языка общего назначения (см. \ref{sec:ch1/sec2}),
имеет как определенные преимущества, так и недостатки.
К преимуществам можно отнести:
\begin{itemize}
    \item ограничение пользователя языка только необходимыми конструкциями -- минимизация ошибок программирования;
    \item точные, по сравнению с языком общего назначения, сообщения об ошибках;
    \item самодокументируемость решения проблемы;
    \item более эффективная, по времени, разработка.
\end{itemize}

К недостаткам -- необходимость предварительного изучения проблемно-ориентированного языка.
Как можно убедиться, преимуществ, несмотря на определенную трудоемкость разработки такого языка,
больше.
Необходимость изучения дополнительного языка для описания виртуального устройства может показаться
избыточной, но использование языка общего назначения (см. \ref{sec:ch1/sec2}),
пусть и популярного, не гарантирует, что пользователь его знает и эффективно в нем работает.
Помимо этого, изучение небольшого языка для решения конкретной проблемы будет эффективнее
изучения библиотеки и некоторого подмножества полноценного языка программирования,
из которого ее можно будет использовать.

Ограничение в языковых конструкциях и анализ семантики исходного кода
позволяет точно инструктировать пользователя об ошибках в реализации виртуального устройства,
что ведет к отсутствию ошибок уровня интерфейса устройства,
сводя появление возможных неисправностей только до реализации логики устройства.

Язык-фреймворк Racket \cite{racket-lang} разработан как раз для языково-ориентированного
программирования. Написание на нем логики компилятора или интерпретатора целевого языка
полуавтоматически создает интегрированную среду разработки с помощью IDE DrRacket, которую
также поддерживает сообщество.
После объявления некоторых функций \cite{racket-drracket-integration}, разработчик программ
на целевом языке сможет пользоваться подсветкой синтаксиса, отладчиком, автоматическим добавлением
отступов и указателями использования переменных (рис. \ref{fig:racket-variable-arrow}), что дополнительно облегчает разработку.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/racket-variable-arrow.png}
    \end{adjustbox}
    \caption{Результат интеграции языка datalog в IDE DrRacket.}\label{fig:racket-variable-arrow}
\end{figure}


\subsubsection{Структура программы}\label{sec:ch2/sec1/sub1/sub1}

Структура программы-описания аппаратного обеспечения имеет следующий вид, рисунок \ref{fig:device-program-structure}.

\begin{figure}[!htbp]
    \centering
    \input{images/program-structure.tikz}
    \caption{Структура программы-описания аппаратного обеспечения.}\label{fig:device-program-structure}
\end{figure}

Несмотря на то, что компилятор язык программы-описания располагает
блоки кода в результирующем тексте модуле QEMU в соответствии
с правилами языка C и порядок объявления блоков в исходном файле ему не важен,
данная структура является наиболее понятной и органичной для стороннего разработчика.
Поэтому компилятор принуждает программиста придерживаться её, подобно тому, как
язык Python обязывает использовать отступы для создания блоков кода.


\subsubsection{Граммматика языка}\label{sec:ch2/sec1/sub1/sub2}
Разрабатываемый язык является языком с контекстно-свободной грамматикой.
Далее он будет именоваться как {\mylanguage} (произносится \mylanguageprononciation)

Грамматика {\mylanguage} ограничена до описания зависимостей устройства и QEMU,
связывания функций C и Python, встраивания Python-кода с логикой работы устройства
в файл.


% TODO: Учтено ли, что пользователь захочет кастомизировать функции инициализации класса и инстанса?
% TODO: MemoryRegionOps?
\setlength{\grammarparsep}{0.1cm}
\setlength{\grammarindent}{13em}
\begin{figure}[!htbp]
    \begin{grammar}
        <letter> ::= `a' ... `z' | `A' ... `Z';

        <digit> ::= `0' ... `9' ;

        <symbol> ::= \symbol{92}x20 ... \symbol{92}x7E ; (* любой печатный символ, согласно кодам ASCII *)

        <const value> ::= <digit> | `"' \{ <symbol> \} `"';

        <identifier> ::= <letter> [\{ <letter> | <digit> | `\_' \}] ;

        <block start> ::= `{';

        <block end> ::= `}';

        <field> ::= <identifier> `=' <identifier> | <block> ;

        <block> ::= <block start> <field> [\{ `,' <field> \}] <block end>;

        <device definition> ::= '\#' <identifier>;

        <device class inheritance> ::= `(' <identifier> `:' <identifier> [\{ `,' <identifier> \}] `)';

        <device class block> ::= <device class inheritance> <block>;

        <bind block> ::= `@bind' <block>;

        <python block> ::= `@py' <block>;

        <program> ::= <device definition> <device class block> <bind block> <python block>;
    \end{grammar}
    \caption{Расширенная форма Бэкуса-Наура \mylanguage}\label{fig:qpydev-grammar}
\end{figure}


\subsubsection{Семантика языка}\label{sec:ch2/sec1/sub1/sub3}

Для описания семантики языка {\mylanguage} была выбрана денотационная семантика.
Краеугольным камнем денотационной семантики является определение для каждой сущности
языка некоего математического объекта и некоей функции, называемой интерпретатором,
которая отображает экземпляры этой сущности в экземпляры этого математического объекта -- элемент множества денотаций.
Поскольку математические объекты строго определены, то они представляют собой точный
смысл соответствующих сущностей.

Функции обозначают посредством двойных квадратных скобок $[[$ $]]$,
а элемент алгебры или операция алгебры, сопоставленные функцией $[[$ $]]$
правильному выражению или конструктору выражений, называют денотантом этого выражения или,
соответственно, денотацией конструкции. \cite{denotational-semantics}

Для языка {\mylanguage} значимыми множествами семантических объектов
являются только множества $Q$ -- объектов QEMU (переменные, функции, структуры) и
$C$ -- множество константных выражений.


\begin{figure}[!htbp]
    \centering
    \begingroup
    \addtolength{\jot}{1em}
    \begin{align*}
        [[assignment]](x,y) ={}& \lambda x.y \\
        [[terminate]](m) ={}& \text{ Завершение работы компилятора} \\
        [[if]](c,e_1,e_2) ={}&
        \begin{cases}
            e_1, & \text{Если } c = true \\
            e_2, & \text{Если } c \not= true
        \end{cases} \\
        [[throw\ error]](c, e) ={}& if(c, e_g, terminate) \\
        [[lookup]](o) ={}& [[throw\ error]](o \in Q, o) \\
        [[<device\ definition>]](i) ={}& lookup(i) \\
        [[<device\ class\ inheritance>]](i_1,...,i_n) ={}& lookup(i_1) + ... + lookup(i_n) \\
        [[<field>]](v_1, v_2) ={}& assignment(v_1, v_2),\\ & \text{ Если } v_1 \in Q \text{ и } v_3 \in C \cup Q \\
        [[<block>]](f_1,...,f_n) ={}& field(f_1) + ... + field(f_n) \\
        [[<python block>]](b) ={}& assignment(B,B)\\
    \end{align*}
    \endgroup
    \caption{Денотационная семантика {\mylanguage}}\label{fig:denotational-semantics}
\end{figure}


\subsection{Поиск используемых сущностей QEMU}\label{sec:ch2/sec1/sub2}

Пробрасывание -- процесс преобразовывания и передачи данных между двумя интерфейсами.

Поиск используемых сущностей состоит в установлении типов QEMU для последующего
корректного пробрасывания их в логику устройства.
Также это необходимо для проверки корректности наследования и встраивания устройства.
Необходимыми для пробрасывания типами являются структуры и функции, оперирующие ими.

Рекурсивное преобразование структур QEMU в типы python важно для удобного и читаемого
использования C-объектов внутри python-логики.
Пробрасывание в python функций QEMU необходимо для использования уже имеющегося API эмулятора.
% TODO: может удалить, если это сложно
Потенциально, может быть удобным использование макросов препроцессора C внутри
логики Python.

Базовым классом для всех классов QEMU является класс \texttt{Object}.
Наследование происходит через определение первым членом C-структуры
указателя на структуру-родитель данной. Так как язык C гарантирует, что
первый член структуры всегда начинается с нулевого отступа от начала
структуры, любой класс можно привести к типу Object.
В свою очередь Object содержит структуру, описывающую класс приведенного
объекта -- \texttt{ObjectClass}, что позволяет определить реальный тип указателя
во время исполнения.

Структуры \texttt{TypeImpl} и \texttt{TypeInfo} (см рис. \ref{fig:qom-structure}) практически не отличаются,
но служат для разных целей:
\texttt{TypeImpl} является <<внутренним>> содержанием класса, служебной структурой,
которая скрывает методы класса от пользователя интерфейса, тогда как \texttt{TypeInfo}
наоборот, предоставляет уже очищенный от служебных полей интерфейс для инициализации \texttt{TypeImpl}.

После объявления \texttt{TypeInfo}, структура регистрируется в объектной системе QEMU.
Это происходит через использование макроса \texttt{type\_init}, который создает, можно считать,
анонимную функцию, в свою очередь вызывающую функцию \texttt{register\_module\_init}.
Созданная анонимная функция помечается атрибутом \texttt{constructor} \cite{gcc-attributes}, что заставляет
компилятор добавить вызов такой функции до вызова функции main.
Соответственно, инициализация модулей происходит до того, как начнет исполняться логика QEMU.

% TODO: А точно ли?

Все перефирийные устройства, добавляемые в QEMU, <<общаются>> с другими устройствами через чтение и запись
по определенным для устройства адресам памяти.
За это отвечает структура \texttt{MemoryRegionOps} \ref{fig:mem-reg-ops},
которая инициализируется функциями чтения и записи,
которые вызываются, соответственно, при чтении или записи памяти, на которое <отображено>> устройство.
Данные функции принимают на вход указатель на устройство, в чью память происходит чтение или запись,
адрес, по которому происходит чтение или запись, и, в случае чтения, количество читаемых байт,
а в случае записи -- записываемое значение и количество записываемых байт.
Некоторые устройства используют расширенные версии чтения и записи, где последним аргументом передается
структура с атрибутами транзакции.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/mem_reg_ops_cropped.png}
    \end{adjustbox}
    \caption{Связь \texttt{MemoryRegionOps} с другими сущностями QEMU.}\label{fig:mem-reg-ops}
\end{figure}


\subsubsection{Механизм нахождения информации о типах устройств}\label{sec:ch2/sec1/sub2/sub1}

Все устройства QEMU:
\begin{enumerate}[label={\arabic*)}]
    \item имеют родителя и распределены по подпапкам папки \texttt{hw};
    \item объявляют структуру \texttt{TypeInfo}, в которой указывается родитель устройства
          и размер создаваемого объекта -- поле \texttt{.instance\_size}
          (используется для создания объектов устройств на системной шине);
    \item используют оператор \texttt{sizeof},
          передавая ему имя структуры устройства, которое будет исполняться в QEMU.
\end{enumerate}

Данная информация позволяет найти используемые сущности QEMU следующим образом:
\begin{enumerate}[label={\arabic*)}]
    \item пройтись по всем файлам, находящимся в папке \texttt{hw};
    \begin{enumerate}[label={\arabic*)}]
        \item найти структуру \texttt{TypeInfo};
        \item проанализировать поле \texttt{.instance\_size} и сохранить
              используемую структуру как возможную для наследования;
        \item сохранить поле \texttt{.name} в качестве имени структуры для наследования;
    \end{enumerate}
\end{enumerate}

Помимо явного описания структуры \texttt{TypeInfo} некоторые устройства, написанные
в современном стиле, используют макросы:
\begin{enumerate}[label={\arabic*)}]
    \item \label{main-def-macro} \texttt{OBJECT\_DEFINE\_TYPE\_EXTENDED};
    \item \texttt{OBJECT\_DEFINE\_TYPE};
    \item \texttt{OBJECT\_DEFINE\_TYPE\_WITH\_INTERFACES};
    \item \texttt{OBJECT\_DEFINE\_ABSTRACT\_TYPE}.
\end{enumerate}

Все перечисленные макросы создают структуру \texttt{TypeInfo} и все, кроме \ref{main-def-macro},
вызывают внутри себя макрос \ref{main-def-macro}, специализируя определенные поля структуры \texttt{TypeInfo}.
Например \texttt{OBJECT\_DEFINE\_ABSTRACT\_TYPE} создает абстрактный тип, передавая внутри себя
значение \texttt{true} макросу \texttt{OBJECT\_DEFINE\_TYPE\_EXTENDED}, чем облегчает собственный интерфейс
и делает свое использование более выразительным.

Список аргументов макросов объявления типов также требуется разбирать, чтобы получить из аргументов информацию
о структуре \texttt{TypeInfo}.

Механизм получения информации о функциях намного проще: в языке C функции могут инкапсулироваться
только на уровне одного модуля трансляции -- C-файла, прошедшего этап препроцессирования.
Инкапсулированные функции помечаются ключевым словом \texttt{static}, что делает их
<<невидимыми>> в других модулях трансляции.
Все функции, не помеченные ключевым словом \texttt{static} будем считать интерфейсными.

Данная информация будет использована впоследствии для корректной кодогенерации устройства
и преобразования C-структур и C-функций в читаемый вид для python-интерфейса.

\subsubsection{Механизм использования информации о типах устройств}\label{sec:ch2/sec1/sub2/sub2}

Так как код QEMU насыщен использованием макросов, потребуется инструмент для их разворачивания -- препроцессор.
Чтобы не создавать собственную имплементацию препроцессора, этим будет заниматься препоцессор системного компилятора.

Практически во всех системах сборки программ в POSIX окружении используется компилятор gcc или clang.
Оба компилятора являются совместимыми между собой. Для задействования препроцессора компилятора используется
опция \texttt{-E}. Так как препроцессор C, помимо раскрытия макросв занимается еще нахождением и подстановкой
заголовочных файлов, то потребуется указать папки с их местонахождением.
QEMU полагается на:
\begin{enumerate}[label={\arabic*)}]
    \item \label{build-header} заголовочные файлы, создаваемые в процессе сборки эмулятора;
    \item библиотеку GLib;
    \item заголовочные файлы, находящиеся в папке \texttt{include}.
\end{enumerate}

Так как файлы в пункте \ref{build-header} появляются в процессе сборки, то конкретную версию QEMU нужно будет собрать.
Сборка также полезна, так как в процессе конфигурации эмулятора выставляются определенные переменные
препроцессора (дефайны -- от директивы \texttt{\#define}), которые влияют на условные выражения
препроцессора, а те, в свою очередь, на генерацию исходного кода.
Использование в данном случае статического анализатора кода было бы затруднительным, так как
информация о конкретной конфигурации не может быть получена без непосредственной сборки.

Укзание папки для препроцессора производится с помощью опции \texttt{-I}.
\begin{lstlisting}[caption={Пример строки запуска препроцессора для определенного файла устройства},
                   captionpos=b]
gcc -E hw/misc/edu.c
    -I ./include/
    -I ./build/
    -I/usr/include/glib-2.0
    -I/usr/lib64/glib-2.0/include
\end{lstlisting}


\subsection{Генерация python-интерфейса для логики устройства}\label{sec:ch2/sec1/sub3}

% TODO: как это вяжется со SWIG'ом?
Определение интерфейса используемых сущностей QEMU происходит в уже препроцессированном коде \ref{sec:ch2/sec1/sub2/sub2}.
Python, в эталонной реализации, является интерпретируемым языком программирования со сборщиком мусора.
Python спользует для сбора мусора подсчет ссылок и поколенческий сборщик мусора, чей API описан в модуле \texttt{gc}.
Уничтожение объектов, основанное на подсчете ссылок использует простое правило: если на объект больше
никто не ссылается, то память, занимаемая объектом, высвобождается.
Классическим недостатком данного подхода являются циклические ссылки: если объект \textit{A} ссылается
на объект \textit{B} (или же сам на себя), а тот, в свою очередь ссылается на объект \textit{A}, то система, основанная
только на подсчете ссылок, не может определить, реально ли используются оба этих объекта или нет.
В зависимости от языка, принимаются различные меры противодействия данной ситуации
(например Perl 5 никак не детектирует циклические ссылки между объектами,
из-за чего занимаемая ими память возвращается операционной системе только в момент завершения
работы интерпретатора).
В Python для решения данной проблемы используется поколенческий сборщик мусора (generational garbage collector),
который переодически запускается. Сборщик мусора выделяет три поколения объектов,
различающихся интервалами сканирования на предмет <<мусора>>:
\begin{itemize}
    \item первое поколение -- в него попадают все новые объекты;
    \item второе поколение -- если объект выжил после сборки мусора
        в первом поколении, то он перемещается во второе;
    \item третье поколение проверяется на наличие мусора только когда
        соотношение $\frac{\text{объекты, перемещаемые в верхнее поколение}}{\text{количество объектов второго и третьего поколения}} > 25\%$;
\end{itemize}

Тогда как поколенческий сборщик мусора можно отключить, подсчет ссылок нельзя, он ведется автоматически
для Python-кода и вручную C-кода с помощью макросов \texttt{Py\_INCREF} и \texttt{Py\_XINCREF}
увеличивают счетчик ссылок на объект, \texttt{Py\_DECREF} и \texttt{Py\_XDECREF}.
Разница между \texttt{X}-макросами и обычными состоит в том, что \texttt{X}-макросы
проверяют равенство передаваемого указателя \texttt{NULL}, из-за чего исполняются дольше.
Если указатель нулевой, то макрос ничего не делает.
Использование \texttt{Py\_DECREF} или \texttt{Py\_INCREF} на \texttt{NULL} приведет к ошибке во время исполнения.
Помимо этого нужно иметь в виду, что \texttt{Py\_DECREF} (и \texttt{Py\_XDECREF}) могут потенциально
привести к исполнению произвольного кода на Python, так как, в случае обнуления счетчика
ссылок у объектов, для которых определен деструктор (например освобождающий подключение к базе данных),
перед удалением объекта он будет вызван.


\subsubsection{Генерация Python-интерфейса для C-кода}\label{sec:ch2/sec1/sub3/sub1}

Язык Python является скорее интерфейсом, чем языком программирования:
документация описывает то, какие функции и конструкции должен предоставлять язык, чтобы являться Python'ом.
Подтверждением этому служит большое количество различных реализаций языка, например:
\begin{itemize}
    \item IronPython/Jython -- интерпретатор, работающий в CLR и JVM соответственно;
    \item PyPy -- JIT-интерпретатор, изначально написанный на самом Python;
    \item CPython -- эталонный интерпретатор Python, написанный на языке C;
\end{itemize}

Под языком Python практически всегда понимается интерпретатор CPython, как раз его
API для создания связки между кодом на C и Python и будет использоваться.

Для создания бесшовной интеграции, требуется:
\begin{itemize}
    \item преобразовывать C-структуры и C-функции в Python-объекты;
    \item оборачивать C-функции для конвертации Python-аргументов в C-типы;
    \item транслировать изменения связанных объектов внутри Python-кода.
\end{itemize}

\paragraph{SWIG} --  Simplified Wrapper and Interface Generator.
Данное ПО позволяет автоматически генерировать обертки над C/C++ библиотеками для
большого спектра высокоуровневых языков программирования (рис. \ref{fig:swig}).
Для этого требуется написать интерфейсный файл, в котором будут описаны шаблоны
функций и структур, для которых требуется сгенерировать интерфейс.
SWIG принимает на вход файл с описанием шаблонов для нахождения структур и
функций, которые будут экспортированы в межъязыковой интерфейс.
Не смотря на удобство, SWIG не обладает возможностями препроцессора и понимает
только ограниченное количество его директив, причем \texttt{define}'ы воспринимает
только если они объявляют константы.

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/swig.png}
    \end{adjustbox}
    \caption{Схема работы SWIG.}\label{fig:swig}
\end{figure}

Исходя из этого и того, что SWIG генерирует очень большое количество кода,
который все равно придется дополнять обращениями к C-API Python то логичнее
реализовать свое нахождение и преобразование C-сущностей.

Для этого используется пакет c-utils \cite{c-utils} для языка Racket.
В нем реализован разбор грамматики, с учетом всех особенностей
языка: в C имеется два лексических класса, которые считаются
отличными в грамматике, но их использование идентично.
Это типы и их псевдонимы, задаваемые ключевым словом \texttt{typedef}.
Язык различает два этих класса по их связке с типом, поэтому
парсерам приходится поддерживать внутреннее окружение и предоставлять
его лексеру \cite{c-utils-internals}.

В Python существует несколько способов импорта C-сущностей:

\begin{enumerate}[label={\arabic*)}]
    \item \texttt{PyCapsule} -- позволяет инкапсулировать и передавать данные, находящиеся по некому указателю
          сквозь Python-код обратно в C. Сам Python не имеет доступа к инкапсулированному объекту
          так как не сохраняет никакой информации о типе. Ограничением в использовании \texttt{PyCapsule}
          является невозможность работы с данным объектом из многопоточного кода, так как
          Python не может его сериализовать;
    \item \texttt{memoryview} -- созданные объекты являются <<отображениями>> памяти, дают доступ
          к некоторому C-буферу, обозначенному при создании объекта. Можно использовать для
          экспорта сущностей, но с перекладыванием ответственности на интерпретацию байтов буфера
          на Python-код;
    \item Создание Python-объекта, отражающего C-сущность. Можно выполнить отдельным классом или
          же словарем.
\end{enumerate}

В {\mylanguage} для C-сущностей генерируются классы (рис. \ref{fig:py-api-compilation}), отражающие их внутреннее устройство.
Объекты классов не имеют полей, и могут быть использованы только через оператор \texttt{[]}.
В пардигме Python, данный оператор является <<синтаксическим сахаром>> для вызова <<магических>>
функций \texttt{\_\_setitem\_\_} для выставления поля и \texttt{\_\_getitem\_\_} для получения значения.
В данном случае для \texttt{\_\_setitem\_\_} и \texttt{\_\_getitem\_\_} согласно C-API \cite{python-c-type-objects}
генерируются функции, которые первым делом производят конвертацию Python-типов в C-типы,
после чего уже возвращают или выставляют сконвертированные значения в структуры (листинг \ref{lst:python-c-type-objects}).

\begin{lstlisting}[caption={Пример доступа к элементу структуры из Python.},
                   captionpos=b,
                   language=python]
# вызывается функция __getitem__, которая по возможности
# конвертирует C-тип в Python-тип и возвращает Python-сущность,
# присваивая её переменной source.
source = EduState["dma_state"]["src"]

# вызывается функция __setitem__, которая по возможности
# конвертирует Python-тип в C-тип, после чего
# полю EduState.dma_state.dst присваивается значение.
EduState["dma_state"]["dst"] = source + 0x1234
\end{lstlisting}\label{lst:python-c-type-objects}

\begin{figure}[!htbp]
    \centering
    \hspace*{-10cm}
    \begin{minipage}{10cm}
        \input{images/py-api-compilation.tikz}
    \end{minipage}
    \caption{Схема создания Python-сущностей для структур QEMU.}\label{fig:py-api-compilation}
\end{figure}

Создание функций, обращающихся к Python-логике тривиальнее, так как их создание следует
линейному алгоритму (рис. \ref{fig:py-api-func-gen-algo-compilation}).

\begin{figure}[!htbp]
    \centering
    \input{images/py-api-func-gen-algo.tikz}
    \caption{Алгоритм генерации C-функции со связкой Python-логики.}\label{fig:py-api-func-gen-algo-compilation}
\end{figure}

Для улучшения человекочитаемости сгенерированного устройства, в код вставляются макросы с
частоиспользуемыми конструкциями (рис. \ref{fig:py-api-func-compilation}).

\begin{figure}[!htbp]
    \centering
    \begin{adjustwidth*}{-1cm}{}
        \input{images/py-api-func-compilation.tikz}
    \end{adjustwidth*}
    \caption{Пример сгенерированной C-функции, связанной с Python-логикой.}\label{fig:py-api-func-compilation}
\end{figure}

\subsection{Генерация C-интерфейса устройства в QEMU}\label{sec:ch2/sec1/sub4}

Помимо генерации Python-интерфейса для согласования передачи данных между эмулятором
и логикой устройства, требуется соблюсти внутренний интерфейс QEMU для интеграции
модулей.

Как уже было сказано ранее \ref{sec:ch2/sec1/sub2}, аппаратное обеспечение регистрируется
в QEMU динамически, до исполнения функции \texttt{main}.
Для этого метаинформацией о создаваемом устройстве заполняется (возможно с помощью макроса)
структура \texttt{TypeInfo}, на основе которой создается и затем добавляется во внутреннюю
хэш-таблицу типов \texttt{TypeImpl}. Ключами в данной таблице являются имена типов
(поле \texttt{.name} \texttt{TypeInfo}), а значениями, соответственно, созданные \texttt{TypeImpl}.
Имена типов используются как для рефлексии -- во время исполнения программы можно узнать,
какое имя у объекта, и динамического преобразования типов.
Несмотря на то, что в C легко преобразовывать типы, в том числе и типы указателей, данный
механизм не имеет проверок правильности преобразования, в отличие, например, от
операции \texttt{dynamic\_cast} в языке C++.

Использование макросов в коде QEMU облегчает объявление технических структур,
унифицирует описания устройств, сокращает код, принуждает к программиста к использованию
единого стиля и иерархии, что положительно сказывается на конечном результате.
Также, использование макросов позволяет сильнее отвязать код от конкретной версии
QEMU.
Исходя из этого, алгоритм генерации, где это возможно, прибегает к использованию макросов,
нежели кодогенерации структур и функций.

\subsubsection{Грамматика {\mylanguage} для создания устройств QEMU}\label{sec:ch2/sec1/sub4/sub1}

В грамматике языка {\mylanguage} 3 нетерминала:
\texttt{<device definition>}, \texttt{<device class inheritance>}, \texttt{<device class block>},
относятся к описанию класса QEMU-устройства, 1 -- \texttt{<python block>} к описанию Python-кода
и еще 1, \texttt{<bind block>} к связыванию Python-кода с C-кодом (см. \ref{sec:ch2/sec1/sub1/sub2}).

\texttt{<device definition>} объявляет тип создаваемого устройства, из которого автоматически
генерируются (рис. \ref{fig:qemu-module-example}):
\begin{itemize}
    \item имя типа устройства -- CamelCase переводится в snake\_case;
    \item префикс для формирования имен функций устройства (в snake\_case);
    \item синоним типа устройства.
\end{itemize}

На этом этапе автоматически создаются прототипы функций для QOM, все
с префиксом типа устройства в snake\_case:
\begin{itemize}
    \item \texttt{class\_init} -- функция, инициализирующая класс устройства.
        Вызывается до старта \texttt{main}. Нужна для определения виртуальных методов.
        Так как в С нет поддержки уровня языка для создания виртуальных методов
        класса, то данный механизм реализован через поля структур, которые хранят
        указатели на функции. Присвоив к такому полю указатель на другую функцию
        с той же сигнатурой, произойдет, де-факто, переопределение виртуального метода.
        Вызывается после инициализации родительских классов;
    \item \texttt{instance\_init} -- функция-конструктор объекта. Вызывается после
        инициализации родительских классов;
    \item \texttt{instance\_post\_init} -- функция, опционально, завершающая инициализацию
        объекта. Вызывается только когда все \texttt{instance\_init} уже были вызываны;
    \item \texttt{instance\_finalize} -- функция-деструктор. Взывается при уничтожении
        объекта. Вызывается до вызова аналогичной функции в родительском классе.
        Должна освобождать поля, уникальные только для своего типа;
\end{itemize}\label{enum:qemu-class-functions}

Логично описывать специализированную логику инициализации классов,
объектов QEMU, их конструкторов и деструкторов, как и всю остальную логику, в Python.
Поэтому, в случае, если программист в \texttt{<python block>} объявляет функции с именами,
соответствующими \ref{enum:qemu-class-functions}, данные Python-функции будут вызваны
в конце соответствующих C-функций, после прохождения необходимых инициализаций.
Если программисту хочется использовать другие Python-функции в иных контекстах,
данные Python-функций также описываются в блоке \texttt{<bind block>},
что <<экспортирует>> их в C: для каждой Python-функции создается C-функция,
которая оборачивает в себя подготовку и вызов непосредственно Python-функции, а так же
преобразование возвращаемого Python-функцией значения.


\begin{figure}[!htbp]
    \centering
    \hspace*{-10cm}
    \begin{minipage}{10cm}
        \input{images/qemu-module-example.tikz}
    \end{minipage}
    \caption{Пример сгенерированного QEMU-устройства}\label{fig:qemu-module-example}
\end{figure}

\texttt{<device class inheritance>} объявляет класс устройства и специфицирует
его родителя и, опционально, реализуемые устройством интерфейсы.
Классы в QEMU не поддерживают множественное наследование, так как
оно вносит слишком много сложностей при незначительных преимуществах.
Вместо этого, QEMU, как и многие современные объектно-ориентированные языки,
поддерживают механизм интерфейсов: пользователь интерфейса обязан реализовать
его, если наследуется от интерфейса. Причем сам интерфейс не содержит каких-либо
реализаций функций -- он является <<контрактом>>, позволяющим программисту гарантировать,
что у объекта будут реализованы функции, определенные интерфейсом.

\texttt{<device class block>} это совмещение \texttt{<device class inheritance>} и определения полей класса. В этом блоке объявляются типы
полей, сами поля инициализируются. Поддерживаются поля как простых типов, так и структур, объединений.

\subsection{Проброс ошибок QEMU из и в Python}\label{sec:ch2/sec1/sub5}
Парадигмы обработки и извещения об ошибках отличаются в Python и в C.
В C используется механизм возвращаемых значений, в Python -- исключения.
В некоторых проектах, например в загрузчике GRUB, с помощью макросов и
внутренних структур имитируется механизм исключений \cite{grub-error-handling}.
Заголовочный файл \texttt{errno.h} стандартной библиотеки C объявляет
коды ошибок, соответствующие им сообщения и одноименную переменную,
которая содержит в себе код последней ошибки.
Зачастую C-функции возвращают в качестве ошибки $-1$ или \texttt{NULL},
если функция работает с указателями или структурами.
Для некоторых функций такие возвращаемые значения могут являться корректными
и не означать, что произошла какая-либо ошибка.
В таком случае проверяется переменная \texttt{errno}, которая
является локальной для каждого потока.

В Python используется механизм исключений: вызываемая функция может <<бросить>> исключение определенного типа,
а вызывающая функция <<поймать>> его. Исключения являются более высокоуровневыми конструкциями, чем
коды возврата, позволяют добавить к самому исключению некоторое сообщение, а интерпретатор, в случае,
если исключение не <<поймано>>, выведет ошибку и укажет, где исключение было <<брошено>>.
Исключения распространяются вверх по стеку вызовов, в поиске обработчика, который может
обработать исключение данного типа, либо первого из родительских типов.
Из-за такого поиска <<бросание>> исключений становится дорогим в плане требуемых вычислений и
проигрывает коду, где код ошибки является возвращаемым значением.
Конструкция \texttt{try-except} в Python имеет опциональные ветвления:
\begin{itemize}
    \item \texttt{else}, если исключение не произошло;
    \item \texttt{finally}, вызывается в любом случае, в основном используется для очистки ресурсов.
\end{itemize}

Получить доступ ко всем классам Python-исключений из C-API просто -- они являются глобальными переменными.
Базовый класс всех исключений доступен по имени \texttt{PyExc\_Exception}.
Функция \texttt{PyErr\_Occured} позволяет узнать, происходило ли в Python необработанное исключение
впринципе, а \texttt{PyErr\_Fetch} получить три составляющих последнего исключения:
\begin{itemize}
    \item тип исключения;
    \item значение исключения (в основном строковые сообщения);
    \item трейсбек -- сохраненный стек вызовов на момент выбрасывания исключения.
\end{itemize}

В случае, если исключения нет, то все три значения будут \texttt{NULL}'ами,
причем, если исключение действительно было брошено, то значение
исключения и трейсбек могут быть \texttt{NULL}'ами (например исключение, произошедшее
в модуле C-расширения), так как являются опциональными.
\texttt{PyErr\_Restore}, в свою очередь, выставляет внутренний индикатор
исключений из перечисленных объектов.
Две данные функции используются в паре, если требуется запомнить исключение
перед исполнением и восстановить после завершения действий,
которые потенциально могут привести к возникновению новых исключений.

% Можно написать, как Python воспринимает ошибки из Си
Существует несколько способов из C-модуля бросить исключение в Python:
\begin{itemize}
    \item \texttt{PyErr\_SetString} -- получает аргументами тип исключения
        и сообщение, его описывающее;
    \item \texttt{PyErr\_SetFromErrno} -- получает тип исключения в качестве
        аргумента, а сообщение из переменной \texttt{errno};
    \item другие, более низкоуровневые функции, на которых основывается
        \texttt{PyErr\_SetString} и \texttt{PyErr\_SetFromErrno}.
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[scale=1.5]{images/python_exception_hierarchy.png}
    \end{adjustbox}
    \caption{Иерархия исключений в Python.}\label{fig:python-exception-hierarchy}
\end{figure}

За любым неудачным выделением памяти должен следовать вызов \texttt{PyErr\_NoMemory},
бросающий в интерпретатор исключение о нехватке памяти.
Для игнорирования исключений вызванных функций, внутренний контейнер интерпретатора должен
быть явно очищен от исключения вызовом функции \texttt{PyErr\_Clear}.
Использоваться она должна только если вызывающая функция не хочет уведомлять интерпретатор
о произошедшем исключении и готова обработать его самостоятельно.

В случае, если исключение происходит в критически-важных функциях, вроде <<опознания>>
PCI-устройства, требуется корректно уведомить об этом QEMU.

\subsubsection{Подход QEMU к обработке ошибок}\label{sec:ch2/sec1/sub5/sub1}

Модель ошибок в QEMU была, как и многое, вдохновлена моделью ошибок GLib.
В отличие от GLib, где класс исключения инкапсулирует в себе область, код ошибки и сообщение (рис. \ref{fig:glib-error}),
класс исключения в QEMU более подробный (рис. \ref{fig:qemu-error}) и помимо перечисленных полей содержит еще:
\begin{itemize}
    \item подсказку -- содержит дополнительную информацию, помимо сообщения;
    \item название файла и функции, в которых произошла ошибка;
    \item номер строки, где произошла ошибка.
\end{itemize}

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/glib-error.png}
    \end{adjustbox}
    \caption{Класс исключения в GLib.}\label{fig:glib-error}
\end{figure}

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/qemu-error.png}
    \end{adjustbox}
    \caption{Класс исключения в QEMU.}\label{fig:qemu-error}
\end{figure}

Функция \texttt{error\_report} используется для уведомлении пользователя о
прозошедшей ошибке. В отличие от вызова функций печати стандартной библиотеки C,
данная функция, в случае подключенного монитора QEMU (средства управления QEMU
во время работы) выведет сообщение туда, а не в стандартный поток ошибок.

Для бросания ошибок используется макрос \texttt{error\_setg}, который инциализирует
исключение по переданному указателю. Передаваемое исключение должно быть одной из
двух глобальных переменных: \texttt{error\_abort}, \texttt{error\_fatal}.
В случае \texttt{error\_abort}, QEMU выводит сообщение исключения и вызывает
функцию \texttt{abort}, которая посылает работающему процессу (QEMU) сигнал
\texttt{SIGABRT}, вызывающий его экстренное завершение без дальнейшего вызова каких-либо
функций-деструкторов.
\texttt{error\_fatal} в свою очередь вызывает \texttt{exit}, что тоже вызывает
завершение работающего процесса, но с вызовом деструкторов, зарегистрированных
функцией \texttt{atexit}.

Все исключения внутри Python-логики должны быть обработаны. Если происходит
необработанное исключение внутри Python-кода, то функция \texttt{PyObject\_CallObject}
вернет \texttt{NULL} и выставит внутренний контейнер исключений.
В таком случае через \texttt{PyErr\_Fetch} будет получено сообщение произошедшего исключения,
на его основе будет вызвана функция \texttt{error\_setg} с ошибкой \texttt{error\_fatal},
которая корректно завершит работу QEMU.

\subsection{Компиляция Python-логики}\label{sec:ch2/sec1/sub6}

Python является интерпретируемым языком, но прежде чем выполниться,
код, компилируется в байт-код и уже потом исполняется на <<виртуальной машине>> Python.
Интерпретатор может оперировать в двух режимах: REPL и исполнение скриптов.
В первом случае, интерпретатор читает строка за строкой пользовательский
ввод, исполняя его как только сформируется корректная синтаксическая конструкция.
Во втором случае весь код, описанный в файле, первоначально компилируется в байткод и только потом исполняется
(рис. \ref{fig:python-interpreter}).

\begin{figure}[!htbp]
    \centering
    \begin{adjustbox}{max totalsize={\textwidth}{\textheight}}
        \includegraphics[]{images/python-interpreter.png}
    \end{adjustbox}
    \caption{Схема работы интерпретатора Python.}\label{fig:python-interpreter}
\end{figure}

Так как {\mylanguage} создает модуль QEMU, не зависящий от сторонних файлов
на диске (чтобы скомпилированная QEMU могла работать в любом окружении),
код с Python-логикой помещается в отдельный заголовочный файл, в котором
создается строковая переменная, его содержащая.
Данная строковая переменная компилируется во время создания типа устройства
(т.е. до вызова \texttt{main}) с помощью функции \texttt{Py\_CompileString},
создавая Pythono-модуль, после чего Python-модуль импортируется в интерпретатор
через \texttt{PyImport\_ExecCodeModule}, позволяя запрашивать уже у модуля
функции логики устройства.


\subsection{Интеграция устройства в сборку QEMU}\label{sec:ch2/sec1/sub7}

После того, как файлы с исходным кодом устройства были сгенерированы, требуется
интегрировать устройство в сборку эмулятора QEMU.

Не смотря на то, что QEMU собирается meson'ом, в репозитории сохраняется
классический sh-скрипт конфигурации, вызвав который можно включить
или отключить компиляцию определенных устройств и возможностей QEMU.
Для добавления созданного устройства применяется шаблонизированный patch-файл,
в котором шаблонные значения препроцессируются и заменяются конкретными,
после чего patch накладывается на скрипт конфигурации.
Так как скрипт конфигурации постоянно и непредсказуемо может меняться,
то якорями для patch-файла являются неменяющийся код обработки ошибок
и добавление ключевых для компиляции QEMU библиотек (вроде GLib).

Скрипт конфигурации, который называется \texttt{configure} создается
файл \texttt{config-host.mak}, содержащий строки ключ-значение,
который загружается meson'ом и определяют, что именно добавлять в
результирующий исполняемый файл.

\subsection{Сборка QEMU}\label{sec:ch2/sec1/sub8}

\subsection{KVM-ускорение}\label{sec:ch2/sec1/sub9}
